'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var savUtil = require('sav-util');
var savSchema = require('sav-schema');

class VuePayload {
  constructor (opts) {
    this.opts = {
      deepth: 2,
      Vue: null,
      router: null
    };
    this.process = null;
    this.processComponent = processComponent.bind(this);
    Object.assign(this.opts, opts);
  }
  setOptions (opts) {
    Object.assign(this.opts, opts);
  }
  getPayloads (route) {
    let {router, Vue} = this.opts;
    let components = router.getMatchedComponents(route);
    let arr = [];
    getComponentsDepth(Vue, components, this.opts.deepth, arr);
    let payloads = [];
    arr.reduce(this.processComponent, payloads);
    return resolvePayloads(route, payloads)
  }
}

function resolvePayloads (vueRoute, payloads) {
  return savUtil.clone(payloads.reduce((routes, payload) => {
    if (savUtil.isFunction(payload)) {
      payload = payload(vueRoute);
    }
    if (savUtil.isObject(payload)) {
      routes.push(payload);
    } else if (savUtil.isArray(payload)) {
      return routes.concat(payload.map(it => {
        if (savUtil.isString(it)) {
          return {name: it}
        }
        return it
      }))
    } else if (savUtil.isString(payload)) {
      routes.push({name: payload});
    }
    return routes
  }, []))
}

function processComponent (payloads, component) {
  let options = typeof component === 'object' ? component : component.options;
  if (this.process) {
    this.process(options);
  }
  if (options.payload) {
    payloads.push(options.payload);
  }
  return payloads
}

function getComponentsDepth (Vue, components, depth, arr) {
  if (Array.isArray(components)) {
    for (let i = 0; i < components.length; ++i) {
      appendComponent(Vue, components[i], depth, arr);
    }
  } else {
    for (let comName in components) {
      appendComponent(Vue, components[comName], depth, arr);
    }
  }
}

function appendComponent (Vue, com, depth, arr) {
  if (savUtil.isString(com)) {
    com = Vue.component(com);
  }
  if (com) {
    arr.push(com);
    if (depth && com.components) {
      getComponentsDepth(Vue, com.components, depth--, arr);
    }
  }
}

const EVENT_START_PAYLOADS = 'start-process-payloads';
const EVENT_RESOLVE_PAYLOADS = 'resolve-payloads';
const EVENT_FINISH_PAYLOADS = 'finish-process-payloads';
const EVENT_ERROR_PAYLOADS = 'error-process-payloads';

class SavVue extends VuePayload {
  constructor (opts) {
    super(Object.assign({
      fallback: null, // 请求失败后处理回调
      flux: null,
      sav: null,
      cacheField: true,
      cacheEnum: true
    }, opts));
    this.savs = {};
    this.caches = {};
    if (this.opts.sav) {
      this.setSav(this.opts.sav);
    }
    savUtil.bindEvent(this);
    this.opts.router.beforeEach(this.beforeEach.bind(this));
    this.installVue(opts.Vue);
    this.initFlux(opts.flux);
  }

  setSav (sav) {
    sav.inject(this.opts.flux);
    this.savs[sav.name] = sav;
  }

  initFlux (flux) {
    let self = this;
    flux.declare({
      actions: {
        RemoveCache (flux, key) {
          let [savName, cacheKey] = key.split('.');
          if (!cacheKey) {
            cacheKey = savName;
            savName = 'sav';
          }
          self.savs[savName].removeCache(cacheKey);
        }
      }
    });
  }

  installVue (Vue) {
    // {{ 'ResAccountLogin.username' | field }}
    Vue.filter('field', (value, ns) => {
      ns || (ns = 'sav');
      let caches = this.caches;
      if (this.opts.cacheField) {
        if (caches[value]) {
          return caches[value]
        }
      }
      let sav = this.savs[ns];
      let [structName, fieldName] = value.split('.');
      let ret;
      try {
        let struct = sav.schema.getSchema(structName);
        let field = struct.opts.props[fieldName];
        ret = field.text || `${ns}.${value}`;
      } catch (err) {
        ret = `${ns}.${value}`;
      } finally {
        if (this.opts.cacheField) {
          caches[value] = ret;
        }
      }
      return ret
    });
    // {{'GroupRoleEnum.master' | enumText }}
    // {{ 'master' | enumText('GroupRoleEnum') }}
    Vue.filter('enumText', (value, enumName, ns) => {
      ns || (ns = 'sav');
      if (!enumName) {
        let arr = value.split('.');
        value = arr[1];
        enumName = arr[0];
      }
      let uri = `${ns}.${enumName}.${value}`;
      let caches = this.caches;
      if (this.opts.cacheEnum) {
        if (caches[uri]) {
          return caches[uri]
        }
      }
      let sav = this.savs[ns];
      let ret;
      try {
        let schemaEnum = sav.schema.getSchema(enumName);
        ret = schemaEnum.key(value);
      } catch (err) {
        ret = uri;
      } finally {
        if (this.opts.cacheEnum) {
          caches[uri] = ret;
        }
      }
      return ret
    });
    Vue.filter('enumFilter', (value, values) => {
      if (!values) {
        return value
      }
      if (savUtil.isString(values)) {
        values = values.split();
      }
      return value.filter(it => {
        return values.indexOf(it.value) !== -1
      })
    });
  }

  beforeEach (to, from, next) {
    let payloads = this.getPayloads(to);

    if (payloads.length) {
      let {flux, fallback} = this.opts;

      this.emit(EVENT_START_PAYLOADS, {
        id: to.fullPath,
        payloads: payloads.length,
        $route: to
      });

      this.invokePayloads(to, payloads).then((newState) => {
        this.emit(EVENT_FINISH_PAYLOADS, {
          id: to.fullPath,
          $route: to
        });
        if (newState) {
          flux.updateState(newState).then(() => {
            if (to.meta.title) {
              document.title = to.meta.title;
            }
            next();
          });
          return
        }
        next();
      }).catch(err => {
        this.emit(EVENT_ERROR_PAYLOADS, err);
        if (fallback) {
          return fallback(to, from, next, err)
        } else {
          next(err);
        }
      });
      return
    } else {
      this.emit(EVENT_START_PAYLOADS, null);
    }
    if (to.meta.title) {
      document.title = to.meta.title;
    }
    next();
  }

  invokePayloads (vueRoute, payloads) {
    let states = [];
    let routes = payloads.filter((it) => {
      if (savUtil.isObject(it)) {
        let sav = this.savs[it.sav || 'sav'];
        if (sav) {
          if (sav.resolvePayload(it, vueRoute)) {
            if (it.state) {
              states.push(it.state);
            } else {
              return true
            }
          }
        }
      }
    });

    const e = {
      id: vueRoute.fullPath,
      remains: routes.length
    };

    const _decr = function decreasePayloadsRemains () {
      e.remains = (!e.remains || --e.remains) < 0 ? 0 : e.remains;
      this.emit(EVENT_RESOLVE_PAYLOADS, e);
    };

    return Promise.all(routes.map((route) => {
      const p = route.savHandle.invokePayload(route);
      p.then(_decr.bind(this), _decr.bind(this));
      return p
    })).then((args) => {
      args = states.concat(args);
      return args.length ? Object.assign.apply({}, args) : null
    })
  }
}

var isarray = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

/**
 * Expose `pathToRegexp`.
 */
var pathToRegexp_1 = pathToRegexp;
var parse_1 = parse;
var compile_1 = compile;
var tokensToFunction_1 = tokensToFunction;
var tokensToRegExp_1 = tokensToRegExp;

/**
 * The main path matching regexp utility.
 *
 * @type {RegExp}
 */
var PATH_REGEXP = new RegExp([
// Match escaped characters that would otherwise appear in future matches.
// This allows the user to escape special characters that won't transform.
'(\\\\.)',
// Match Express-style parameters and un-named parameters with a prefix
// and optional suffixes. Matches appear as:
//
// "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?", undefined]
// "/route(\\d+)"  => [undefined, undefined, undefined, "\d+", undefined, undefined]
// "/*"            => ["/", undefined, undefined, undefined, undefined, "*"]
'([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))'].join('|'), 'g');

/**
 * Parse a string for the raw tokens.
 *
 * @param  {string}  str
 * @param  {Object=} options
 * @return {!Array}
 */
function parse(str, options) {
  var tokens = [];
  var key = 0;
  var index = 0;
  var path = '';
  var defaultDelimiter = options && options.delimiter || '/';
  var res;

  while ((res = PATH_REGEXP.exec(str)) != null) {
    var m = res[0];
    var escaped = res[1];
    var offset = res.index;
    path += str.slice(index, offset);
    index = offset + m.length;

    // Ignore already escaped sequences.
    if (escaped) {
      path += escaped[1];
      continue;
    }

    var next = str[index];
    var prefix = res[2];
    var name = res[3];
    var capture = res[4];
    var group = res[5];
    var modifier = res[6];
    var asterisk = res[7];

    // Push the current path onto the tokens.
    if (path) {
      tokens.push(path);
      path = '';
    }

    var partial = prefix != null && next != null && next !== prefix;
    var repeat = modifier === '+' || modifier === '*';
    var optional = modifier === '?' || modifier === '*';
    var delimiter = res[2] || defaultDelimiter;
    var pattern = capture || group;

    tokens.push({
      name: name || key++,
      prefix: prefix || '',
      delimiter: delimiter,
      optional: optional,
      repeat: repeat,
      partial: partial,
      asterisk: !!asterisk,
      pattern: pattern ? escapeGroup(pattern) : asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?'
    });
  }

  // Match any characters still remaining.
  if (index < str.length) {
    path += str.substr(index);
  }

  // If the path exists, push it onto the end.
  if (path) {
    tokens.push(path);
  }

  return tokens;
}

/**
 * Compile a string to a template function for the path.
 *
 * @param  {string}             str
 * @param  {Object=}            options
 * @return {!function(Object=, Object=)}
 */
function compile(str, options) {
  return tokensToFunction(parse(str, options));
}

/**
 * Prettier encoding of URI path segments.
 *
 * @param  {string}
 * @return {string}
 */
function encodeURIComponentPretty(str) {
  return encodeURI(str).replace(/[\/?#]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase();
  });
}

/**
 * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.
 *
 * @param  {string}
 * @return {string}
 */
function encodeAsterisk(str) {
  return encodeURI(str).replace(/[?#]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase();
  });
}

/**
 * Expose a method for transforming tokens into the path function.
 */
function tokensToFunction(tokens) {
  // Compile all the tokens into regexps.
  var matches = new Array(tokens.length);

  // Compile all the patterns before compilation.
  for (var i = 0; i < tokens.length; i++) {
    if (typeof tokens[i] === 'object') {
      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$');
    }
  }

  return function (obj, opts) {
    var path = '';
    var data = obj || {};
    var options = opts || {};
    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent;

    for (var i = 0; i < tokens.length; i++) {
      var token = tokens[i];

      if (typeof token === 'string') {
        path += token;

        continue;
      }

      var value = data[token.name];
      var segment;

      if (value == null) {
        if (token.optional) {
          // Prepend partial segment prefixes.
          if (token.partial) {
            path += token.prefix;
          }

          continue;
        } else {
          throw new TypeError('Expected "' + token.name + '" to be defined');
        }
      }

      if (isarray(value)) {
        if (!token.repeat) {
          throw new TypeError('Expected "' + token.name + '" to not repeat, but received `' + JSON.stringify(value) + '`');
        }

        if (value.length === 0) {
          if (token.optional) {
            continue;
          } else {
            throw new TypeError('Expected "' + token.name + '" to not be empty');
          }
        }

        for (var j = 0; j < value.length; j++) {
          segment = encode(value[j]);

          if (!matches[i].test(segment)) {
            throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '", but received `' + JSON.stringify(segment) + '`');
          }

          path += (j === 0 ? token.prefix : token.delimiter) + segment;
        }

        continue;
      }

      segment = token.asterisk ? encodeAsterisk(value) : encode(value);

      if (!matches[i].test(segment)) {
        throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but received "' + segment + '"');
      }

      path += token.prefix + segment;
    }

    return path;
  };
}

/**
 * Escape a regular expression string.
 *
 * @param  {string} str
 * @return {string}
 */
function escapeString(str) {
  return str.replace(/([.+*?=^!:${}()[\]|\/\\])/g, '\\$1');
}

/**
 * Escape the capturing group by escaping special characters and meaning.
 *
 * @param  {string} group
 * @return {string}
 */
function escapeGroup(group) {
  return group.replace(/([=!:$\/()])/g, '\\$1');
}

/**
 * Attach the keys as a property of the regexp.
 *
 * @param  {!RegExp} re
 * @param  {Array}   keys
 * @return {!RegExp}
 */
function attachKeys(re, keys) {
  re.keys = keys;
  return re;
}

/**
 * Get the flags for a regexp from the options.
 *
 * @param  {Object} options
 * @return {string}
 */
function flags(options) {
  return options.sensitive ? '' : 'i';
}

/**
 * Pull out keys from a regexp.
 *
 * @param  {!RegExp} path
 * @param  {!Array}  keys
 * @return {!RegExp}
 */
function regexpToRegexp(path, keys) {
  // Use a negative lookahead to match only capturing groups.
  var groups = path.source.match(/\((?!\?)/g);

  if (groups) {
    for (var i = 0; i < groups.length; i++) {
      keys.push({
        name: i,
        prefix: null,
        delimiter: null,
        optional: false,
        repeat: false,
        partial: false,
        asterisk: false,
        pattern: null
      });
    }
  }

  return attachKeys(path, keys);
}

/**
 * Transform an array into a regexp.
 *
 * @param  {!Array}  path
 * @param  {Array}   keys
 * @param  {!Object} options
 * @return {!RegExp}
 */
function arrayToRegexp(path, keys, options) {
  var parts = [];

  for (var i = 0; i < path.length; i++) {
    parts.push(pathToRegexp(path[i], keys, options).source);
  }

  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options));

  return attachKeys(regexp, keys);
}

/**
 * Create a path regexp from string input.
 *
 * @param  {string}  path
 * @param  {!Array}  keys
 * @param  {!Object} options
 * @return {!RegExp}
 */
function stringToRegexp(path, keys, options) {
  return tokensToRegExp(parse(path, options), keys, options);
}

/**
 * Expose a function for taking tokens and returning a RegExp.
 *
 * @param  {!Array}          tokens
 * @param  {(Array|Object)=} keys
 * @param  {Object=}         options
 * @return {!RegExp}
 */
function tokensToRegExp(tokens, keys, options) {
  if (!isarray(keys)) {
    options = /** @type {!Object} */keys || options;
    keys = [];
  }

  options = options || {};

  var strict = options.strict;
  var end = options.end !== false;
  var route = '';

  // Iterate over the tokens and create our regexp string.
  for (var i = 0; i < tokens.length; i++) {
    var token = tokens[i];

    if (typeof token === 'string') {
      route += escapeString(token);
    } else {
      var prefix = escapeString(token.prefix);
      var capture = '(?:' + token.pattern + ')';

      keys.push(token);

      if (token.repeat) {
        capture += '(?:' + prefix + capture + ')*';
      }

      if (token.optional) {
        if (!token.partial) {
          capture = '(?:' + prefix + '(' + capture + '))?';
        } else {
          capture = prefix + '(' + capture + ')?';
        }
      } else {
        capture = prefix + '(' + capture + ')';
      }

      route += capture;
    }
  }

  var delimiter = escapeString(options.delimiter || '/');
  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter;

  // In non-strict mode we allow a slash at the end of match. If the path to
  // match already ends with a slash, we remove it for consistency. The slash
  // is valid at the end of a path match, not in the middle. This is important
  // in non-ending mode, where "/test/" shouldn't match "/test//route".
  if (!strict) {
    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?';
  }

  if (end) {
    route += '$';
  } else {
    // In non-ending mode, we need the capturing groups to match as much as
    // possible by using a positive lookahead to the end or next path segment.
    route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)';
  }

  return attachKeys(new RegExp('^' + route, flags(options)), keys);
}

/**
 * Normalize the given path string, returning a regular expression.
 *
 * An empty array can be passed in for the keys, which will hold the
 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
 * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
 *
 * @param  {(string|RegExp|Array)} path
 * @param  {(Array|Object)=}       keys
 * @param  {Object=}               options
 * @return {!RegExp}
 */
function pathToRegexp(path, keys, options) {
  if (!isarray(keys)) {
    options = /** @type {!Object} */keys || options;
    keys = [];
  }

  options = options || {};

  if (path instanceof RegExp) {
    return regexpToRegexp(path, /** @type {!Array} */keys);
  }

  if (isarray(path)) {
    return arrayToRegexp( /** @type {!Array} */path, /** @type {!Array} */keys, options);
  }

  return stringToRegexp( /** @type {string} */path, /** @type {!Array} */keys, options);
}

pathToRegexp_1.parse = parse_1;
pathToRegexp_1.compile = compile_1;
pathToRegexp_1.tokensToFunction = tokensToFunction_1;
pathToRegexp_1.tokensToRegExp = tokensToRegExp_1;

class Router {
  constructor (opts) {
    this.opts = {
      prefix: '',
      caseType: 'camel',
      sensitive: true
    };
    savUtil.bindEvent(this);
    opts && this.setOptions(opts);
    this.modals = {};
    this.actionRoutes = createMethods();
    this.modalRoutes = [];
  }
  setOptions (opts) {
    Object.assign(this.opts, opts);
  }
  declare (routeModals) {
    for (let modalName in routeModals) {
      this.declareModal(modalName, routeModals[modalName]);
    }
  }
  declareModal (modalName, modal) {
    this.removeModal(modalName);
    createModalRoute(this, modalName, modal);
  }
  removeModal (modalName) {
    if (this.modals[modalName]) {
      return removeModal(this, modalName)
    }
  }
  matchRoute (path, method) {
    if (method === 'ANY') {
      for (let submethod of methods) {
        let ret = this.matchRoute(path, submethod);
        if (ret) {
          return ret
        }
      }
    }
    if (methods.indexOf(method) === -1) {
      return
    }
    let uri = savUtil.Url.parse(path);
    path = stripPrefix(uri.path, this.opts.prefix);
    let ret = {
      path
    };
    // 顶级路由
    for (let route of this.actionRoutes[method]) {
      if (matchRoute(route, path, ret)) {
        ret.query = uri.query ? savUtil.Query.parse(uri.query) : {};
        return ret
      }
    }
    for (let route of this.modalRoutes) {
      // 模块路由
      if (matchRoute(route, path)) {
        for (let subRoute of route.routes[method]) {
          // 子级路由
          if (matchRoute(subRoute, path, ret)) {
            ret.query = uri.query ? savUtil.Query.parse(uri.query) : {};
            return ret
          }
        }
      }
    }
  }
}

const methods = ['GET', 'POST', 'PUT', 'DELETE', 'PATCH'];

function createMethods () {
  let ret = {};
  methods.forEach((name) => {
    ret[name] = [];
  });
  return ret
}

function matchRoute (route, path, ret) {
  let mat = path.match(route.regexp);
  if (mat) {
    if (ret) {
      ret.route = route;
      let {keys} = route;
      let params = ret.params = {};
      for (let i = 1, len = mat.length; i < len; ++i) {
        const key = keys[i - 1];
        if (key) {
          const val = typeof mat[i] === 'string' ? decodeURIComponent(mat[i]) : mat[i];
          params[key.name] = val;
        }
      }
    }
    return true
  }
}

function stripPrefix (src, prefix) {
  if (prefix) {
    let pos = src.indexOf(prefix);
    if (pos === 0 || ((pos === 1) && src[0] === '/')) {
      src = src.substr(pos + prefix.length, src.length);
      if (src[0] !== '/') {
        src = '/' + src;
      }
      return src
    }
  }
  return src
}

function removeModal (router, modalName) {
  let modal = router.modals[modalName];
  delete router.modals[modalName];
  router.modalRoutes = router.modalRoutes.filter((route) => route.modal !== modal);
  let actionRoutes = router.actionRoutes;
  methods.forEach((method) => {
    actionRoutes[method] = actionRoutes[method].filter((route) => route.modal !== modal);
  });
  router.emit('removeModal', modal);
  return modal
}

function createModalRoute (router, modalName, modal) {
  let modalRoute = createRoute(router, modalName, modal);
  modalRoute.routes = createMethods();
  router.emit('declareModal', modalRoute);
  for (let actionName in modal.routes) {
    createRoute(router, actionName, modal.routes[actionName], modalRoute);
  }
  router.modals[modalName] = modal;
}

function createRoute (router, name, refer, modalRoute) {
  refer.name = name;
  let route = {};
  let modal = modalRoute ? modalRoute.modal : refer;
  savUtil.prop(route, 'modal', modal);
  let {caseType, sensitive} = router.opts;
  let path = convertPath(refer.path, caseType, name);
  if (!modalRoute) { // modal总是以''开始
    path = normalPath((refer.prefix || '') + '/' + path);
    route.name = savUtil.pascalCase(name);
    router.modalRoutes.push(route);
  } else { // action
    route.name = modalRoute.name + savUtil.pascalCase(name);
    let method = route.method = (refer.method || 'GET');
    let isRelative = path[0] !== '/';
    if (isRelative) { // 相对路由
      path = modalRoute.path + '/' + path;
    }
    if (isRelative) {
      modalRoute.routes[method].push(route);
    } else {
      router.actionRoutes[method].push(route);
    }
    route.actionName = `${modal.name}.${name}`;
    savUtil.prop(route, 'action', refer);
  }
  route.path = normalPath('/' + path);
  route.keys = [];
  route.regexp = pathToRegexp_1(route.path, route.keys, {
    sensitive,
    end: !!modalRoute
  });
  route.compile = pathToRegexp_1.compile(route.path, {
    sensitive,
    end: !!modalRoute
  });
  router.emit('declareAction', route);
  return route
}

function convertPath (path, caseType, name) {
  if (!savUtil.isString(path)) {
    path = savUtil.convertCase(caseType, name);
  }
  return path
}

function normalPath (path) {
  return path.replace(/\/+/g, '/')
}

class ModalAction {
  constructor (opts) {
    this.opts = {};
    this.setOptions(opts);
    this.modals = {};
    this.actions = {};
  }
  setOptions (opts) {
    Object.assign(this.opts, opts);
  }
  declare (modals) {
    for (let modalName in modals) {
      this.declareModal(modalName, modals[modalName]);
    }
  }
  declareModal (modalName, modal) {
    this.removeModal(modalName);
    let actions = this.modals[modalName] = classToObject(modal);
    for (let actionName in actions) {
      this.actions[`${modalName}.${actionName}`] = actions[actionName];
    }
  }
  removeModal (modalName) {
    if (this.modals[modalName]) {
      delete this.modals[modalName];
      modalName = modalName + '.';
      for (let actionName in this.actions) {
        if (actionName.indexOf(modalName) === 0) {
          delete this.actions[actionName];
        }
      }
    }
  }
  getAction (actionName) {
    return this.actions[actionName]
  }
}

const skips = ['constructor'];

function classToObject (target) {
  if (savUtil.isFunction(target)) {
    let proto = target.prototype;
    return Object.getOwnPropertyNames(proto).reduce((tar, it) => {
      if (!~skips.indexOf(it) && typeof savUtil.isFunction(proto[it])) {
        tar[it] = proto[it];
      }
      return tar
    }, {})
  } else {
    return target
  }
}

class Schema$1 {
  constructor (opts) {
    this.opts = {
      schemaReqField: 'request',
      schemaResField: 'response',
      schemaReqPrefix: 'Req',
      schemaResPrefix: 'Res'
    };
    opts && this.setOptions(opts);
    this.schema = new savSchema.Schema();
  }
  setRouter (router) {
    router.on('declareAction', declareActionSchema.bind(this));
  }
  setOptions (opts) {
    Object.assign(this.opts, opts);
  }
  declare (schemas) {
    if (savUtil.isObject(schemas)) {
      for (let schemaName in schemas) {
        let schemaData = schemas[schemaName];
        schemaData.name = schemaName;
        this.schema.declare(schemaData);
      }
    } else if (savUtil.isArray(schemas)) {
      schemas.forEach(it => {
        this.schema.declare(it);
      });
    }
  }
  getSchema (schemaName) {
    return this.schema[schemaName]
  }
  get proxy () {
    let schema = new Proxy(this, {
      get (target, name) {
        return target.getSchema(name)
      }
    });
    return schema
  }
}

function declareActionSchema (actionRoute) {
  if (actionRoute.action) {
    extractSchema(actionRoute, this);
    extractSchema(actionRoute, this, true);
  }
}

function extractSchema (actionRoute, handler, isResponse) {
  let fieldName = isResponse ? handler.opts.schemaResField : handler.opts.schemaReqField;
  let structPrefix = isResponse ? handler.opts.schemaResPrefix : handler.opts.schemaReqPrefix;
  let value = actionRoute.action[fieldName];
  let structName = savUtil.pascalCase((structPrefix + '_' + actionRoute.name).replace(/\./g, '_'));
  if (savUtil.isString(value)) {
    structName = value;
  } else if (savUtil.isObject(value)) {
    if (value.name) {
      structName = value.name;
    } else {
      value.name = structName;
    }
    let {schema} = handler;
    schema.declare(value);
  }
  actionRoute[isResponse ? 'response' : 'request'] = structName;
}

// https://github.com/nodejs/node/blob/f1653cc9b80b521ef5b129537ce1df9098bbdc1b/lib/_http_server.js#L18-L81
let STATUS_CODES = {
  100: 'Continue',
  101: 'Switching Protocols',
  102: 'Processing',
  200: 'OK', // 操作成功时使用
  201: 'Created',
  202: 'Accepted',
  203: 'Non-Authoritative Information',
  204: 'No Content',  // 不需要返回内容时使用
  205: 'Reset Content',
  206: 'Partial Content',
  207: 'Multi-Status',
  208: 'Already Reported',
  226: 'IM Used',
  300: 'Multiple Choices',
  301: 'Moved Permanently',
  302: 'Found',
  303: 'See Other',
  304: 'Not Modified',
  305: 'Use Proxy',
  307: 'Temporary Redirect',
  308: 'Permanent Redirect',
  400: 'Bad Request', // 请求参数不正确时使用
  401: 'Unauthorized', // 没有认证时使用
  402: 'Payment Required',
  403: 'Forbidden', // 没有权限时使用
  404: 'Not Found', // 资源没找到
  405: 'Method Not Allowed', // 方法不支持
  406: 'Not Acceptable',
  407: 'Proxy Authentication Required',
  408: 'Request Timeout',
  409: 'Conflict',
  410: 'Gone',
  411: 'Length Required',
  412: 'Precondition Failed',
  413: 'Payload Too Large',
  414: 'URI Too Long',
  415: 'Unsupported Media Type',
  416: 'Range Not Satisfiable',
  417: 'Expectation Failed',
  418: 'I\'m a teapot',
  421: 'Misdirected Request',
  422: 'Unprocessable Entity',
  423: 'Locked',
  424: 'Failed Dependency',
  425: 'Unordered Collection',
  426: 'Upgrade Required',
  428: 'Precondition Required',
  429: 'Too Many Requests',
  431: 'Request Header Fields Too Large',
  451: 'Unavailable For Legal Reasons',
  500: 'Internal Server Error',
  501: 'Not Implemented',
  502: 'Bad Gateway',
  503: 'Service Unavailable',
  504: 'Gateway Timeout',
  505: 'HTTP Version Not Supported',
  506: 'Variant Also Negotiates',
  507: 'Insufficient Storage',
  508: 'Loop Detected',
  509: 'Bandwidth Limit Exceeded',
  510: 'Not Extended',
  511: 'Network Authentication Required'
};

class Exception extends Error {
  constructor (message, customMessage) {
    if (message instanceof Error) {
      super(message.message);
      this.stacks = (message.stacks && message.stacks.slice()) || [];
      this.stacks.push(message);
      delete message.stacks;
      if (customMessage) {
        this.message = customMessage;
      }
    } else {
      super(message);
      this.stacks = [];
    }
  }
}

class HttpError extends Exception {
  constructor (status, message) {
    super(message || STATUS_CODES[status]);
    this.status = status;
  }
}

class SavBase {
  constructor (opts) {
    savUtil.bindEvent(this);
    this.opts = {
      name: 'sav',
      prod: true
    };
    this.shareOptions(this.router = new Router());
    this.shareOptions(this.modalAction = new ModalAction());
    this.shareOptions(this.schema = new Schema$1());
    this.schema.setRouter(this.router);
    this.routes = {};
    this.router.on('declareAction', (route) => {
      if (route.actionName) {
        let name = route.name;
        this.routes[name] = route;
      }
    });
    this.mocks = {};
    this.init();
    this.setOptions(opts);
  }
  get name () {
    return this.opts.name
  }
  setOptions (opts) {
    Object.assign(this.opts, opts);
  }
  shareOptions (target) {
    target.opts = Object.assign(this.opts, target.opts);
  }
  declare ({actions, schemas, modals, mocks}) {
    if (schemas) {
      this.schema.declare(schemas);
    }
    if (modals) {
      this.router.declare(modals);
    }
    if (actions) {
      this.modalAction.declare(actions);
    }
    if (mocks) {
      Object.assign(this.mocks, mocks);
    }
  }
  resolvePayload (route, vueRoute) {
    let savRoute = this.routes[route.name];
    let schema = this.schema.getSchema(route.name);
    if (savRoute) {
      if (route.merge) {
        route.params = Object.assign({}, vueRoute.params, route.params);
        route.query = Object.assign({}, vueRoute.query, route.query);
      }
      route.path = savRoute.compile(route.params);
      savUtil.prop(route, 'route', savRoute);
      savUtil.prop(route, 'savHandle', this);
      return route
    } else if (schema) {
      let stateName = schema.opts.stateName || route.name;
      let stateData;
      if (schema.schemaType === savSchema.SCHEMA_ENUM) {
        stateData = JSON.parse(JSON.stringify(schema.opts.enums));
      } else {
        stateData = schema.create(Object.assign({}, schema.opts.state));
        if (route.merge) {
          Object.assign(stateData, vueRoute.params, vueRoute.query);
        }
      }
      route.state = {
        [`${stateName}`]: stateData
      };
      return route
    }
  }
  stripError (error) {
    let err;
    if (error instanceof Error) {
      err = Object.assign({
        message: error.message,
        type: error.constructor.name,
        stack: error.stack
      }, error);
    } else if (typeof err !== 'object') {
      return error
    }
    if (this.opts.prod) {
      delete err.step;
      delete err.stack;
      delete err.stacks;
    }
    if (!err.status) {
      if (!(error instanceof HttpError)) {
        err.status = 500;
      }
    }
    return err
  }
  mapPayloadState (argv) {
    let {route, output} = argv;
    let ret;
    if (savUtil.isObject(output)) {
      ret = mapping(argv, output) || mapping(route.action, output) || output;
      let {resState} = route.action;
      let name = resState || route.response;
      if ((resState !== false) && name) {
        return {[`${name}`]: ret}
      }
    }
    return ret
  }
}

function mapping (target, output) {
  let {mapState} = target;
  if (savUtil.isArray(mapState)) {
    return mapState.reduce((ret, name) => {
      ret[name] = getStatePath(output, name);
    }, {})
  } else if (savUtil.isObject(mapState)) {
    let ret = {};
    for (let name in mapState) {
      ret[name] = getStatePath(output, mapState[name]);
    }
    return ret
  } else if (savUtil.isFunction(mapState)) {
    return mapState(output)
  }
  return output
}

function getStatePath (output, stateName) {
  let pos = stateName.indexOf('.');
  while (pos !== -1) {
    output = output[stateName.substring(0, pos)];
    if (!savUtil.isObject(output)) {
      return
    }
    stateName = stateName.substr(pos + 1);
    pos = stateName.indexOf('.');
  }
  return output[stateName]
}

class Request {
  constructor (sav) {
    this.opts = {
      baseUrl: '/',
      stripHeaders: true, // 不返回头部信息
      ajax: savUtil.ajax
    };
    sav.shareOptions(this);
    this.invokeQueues = [this.invoke.bind(this)];
    this.invoker = null;
    savUtil.bindEvent(this);
  }
  setOptions (opts) {
    assign(this.opts, opts);
  }
  before (fn) {
    this.invoker = null;
    this.invokeQueues.unshift(fn);
  }
  after (fn) {
    this.invoker = null;
    this.invokeQueues.push(fn);
  }
  get (url, options) {
    return this.request(assign({method: 'GET', url}, options))
  }
  post (url, options) {
    return this.request(assign({method: 'POST', url}, options))
  }
  put (url, options) {
    return this.request(assign({method: 'PUT', url}, options))
  }
  patch (url, options) {
    return this.request(assign({method: 'PATCH', url}, options))
  }
  del (url, options) {
    return this.request(assign({method: 'DELETE', url}, options))
  }
  request (options) {
    options = assign({
      url: '',
      dataType: 'JSON',
      headers: {
        Accept: 'application/json'
      }
    }, options);
    let {stripHeaders, baseUrl} = this.opts;
    if ('stripHeaders' in options) {
      stripHeaders = options.stripHeaders;
    }
    if (!/^(http(s?):)?\/\//i.test(options.url)) {
      options.url = baseUrl + options.url.replace(/^\//, '');
    }
    if (!this.invoker) {
      this.invoker = savUtil.compose(this.invokeQueues);
    }
    let {invoker} = this;
    let ctx = {request: options};
    let res = invoker(ctx).then(() => stripHeaders ? ctx.response.data : ctx.response);
    return res
  }
  invoke (ctx, next) {
    return new Promise((resolve, reject) => {
      ctx.xhr = savUtil.ajax(ctx.request, (err, data, headers) => {
        if (err) {
          return reject(err)
        }
        try {
          ctx.response = {
            data,
            headers
          };
          this.emit('response', ctx);
        } catch (err) {
          return reject(err)
        }
        resolve();
      });
      this.emit('request', ctx);
    }).then(next)
  }
}

function assign (target, opts) {
  return Object.assign(target, opts)
}

const poly = -306674912;
const table = (() => {
  let c = 0;
  let table = new Array(256);
  for (let n = 0; n !== 256; ++n) {
    c = n;
    c = ((c & 1) ? (poly ^ (c >>> 1)) : (c >>> 1));
    c = ((c & 1) ? (poly ^ (c >>> 1)) : (c >>> 1));
    c = ((c & 1) ? (poly ^ (c >>> 1)) : (c >>> 1));
    c = ((c & 1) ? (poly ^ (c >>> 1)) : (c >>> 1));
    c = ((c & 1) ? (poly ^ (c >>> 1)) : (c >>> 1));
    c = ((c & 1) ? (poly ^ (c >>> 1)) : (c >>> 1));
    c = ((c & 1) ? (poly ^ (c >>> 1)) : (c >>> 1));
    c = ((c & 1) ? (poly ^ (c >>> 1)) : (c >>> 1));
    table[n] = c;
  }
  return table
})();

function crc32 (str, seed) {
  let C = seed ^ -1;
  for (let i = 0, L = str.length, c, d; i < L;) {
    c = str.charCodeAt(i++);
    if (c < 0x80) {
      C = (C >>> 8) ^ table[(C ^ c) & 0xFF];
    } else if (c < 0x800) {
      C = (C >>> 8) ^ table[(C ^ (192 | ((c >> 6) & 31))) & 0xFF];
      C = (C >>> 8) ^ table[(C ^ (128 | (c & 63))) & 0xFF];
    } else if (c >= 0xD800 && c < 0xE000) {
      c = (c & 1023) + 64;
      d = str.charCodeAt(i++) & 1023;
      C = (C >>> 8) ^ table[(C ^ (240 | ((c >> 8) & 7))) & 0xFF];
      C = (C >>> 8) ^ table[(C ^ (128 | ((c >> 2) & 63))) & 0xFF];
      C = (C >>> 8) ^ table[(C ^ (128 | ((d >> 6) & 15) | ((c & 3) << 4))) & 0xFF];
      C = (C >>> 8) ^ table[(C ^ (128 | (d & 63))) & 0xFF];
    } else {
      C = (C >>> 8) ^ table[(C ^ (224 | ((c >> 12) & 15))) & 0xFF];
      C = (C >>> 8) ^ table[(C ^ (128 | ((c >> 6) & 63))) & 0xFF];
      C = (C >>> 8) ^ table[(C ^ (128 | (c & 63))) & 0xFF];
    }
  }
  return C ^ -1
}

class Sav extends SavBase {
  init () {
    this.request = new Request(this);
    this.caches = {};
  }
  inject (flux) {
    let isSav = this.name === 'sav';
    let {schema} = this;
    let actions = Object.keys(this.routes).reduce((ret, route) => {
      route = this.routes[route];
      let actionName = savUtil.pascalCase(route.method.toLowerCase() + '_' + (isSav ? '' : this.name) + route.name);
      ret[actionName] = (flux, data, fetch) => {
        let argv = Object.assign({}, data);
        return this.invoke(flux, argv, route, fetch)
      };
      if (route.keys.length === 0) {
        ret[`${actionName}Data`] = (flux, data, fetch) => {
          let argv = {data};
          return this.invoke(flux, argv, route, fetch)
        };
      }
      let reqStruct = schema.getSchema(route.request);
      if (reqStruct) {
        let reqName = (isSav ? '' : this.name) + route.request;
        ret[`Check${reqName}`] = (flux, data) => {
          return reqStruct.check(data)
        };
        ret[`Extract${reqName}`] = (flux, data) => {
          return reqStruct.extractThen(data)
        };
      }
      let resStruct = schema.getSchema(route.response);
      if (resStruct) {
        let resName = (isSav ? '' : this.name) + route.response;
        ret[`Check${resName}`] = (flux, data) => {
          return resStruct.check(data)
        };
        ret[`Extract${resName}`] = (flux, data) => {
          return resStruct.extractThen(data)
        };
      }
      return ret
    }, {});
    flux.declare({
      actions
    });
  }
  invoke (flux, argv, route, fetch) {
    savUtil.prop(argv, 'route', route);
    return this.invokePayload(argv).then(async data => {
      if (fetch) {
        return data || argv.output
      }
      if (data) {
        await flux.updateState(data);
      }
    })
  }
  async invokePayload (argv) {
    let {schema} = this;
    let {route} = argv;
    argv.url = route.compile(argv.params);
    argv.input = Object.assign({}, argv.params, argv.query, argv.data);
    let ttl = this.opts.noCache ? null : argv.ttl || (route.action.ttl);
    let cacheKey = ttl ? this.getCacheKey(argv) : null;
    let cacheVal = cacheKey ? this.getCache(cacheKey, ttl) : null;
    if (!cacheVal) {
      let reqStruct = schema.getSchema(route.request);
      if (reqStruct) {
        try {
          argv.input = reqStruct.extract(argv.input);
        } catch (err) {
          err.status = 400;
          throw err
        }
      }
      argv.method = route.method;
      let output = await this.fetch(argv);
      let resStruct = schema.getSchema(route.response);
      let cache;
      if (resStruct) {
        resStruct.check(output);
        cache = resStruct.opts.cache;
        if (cache) {
          this.removeCache(cache);
        }
      }
      argv.output = output;
      if (cacheKey) {
        this.setCache(cacheKey, ttl, cache || route.response, output);
      }
    } else {
      argv.output = cacheVal;
    }
    return this.mapPayloadState(argv)
  }
  fetch (argv) {
    if (this.opts.mockState) {
      let mocks = this.mocks[argv.route.response];
      if (mocks && mocks.length) {
        if (this.opts.mockFlow) {
          return new Promise((resolve, reject) => {
            this.emit('mockFlow', {resolve, reject, argv, mocks});
          })
        } else {
          return mocks[0].data
        }
      } else {
        throw new Error(`mock data no found: ${argv.route.response}`)
      }
    }
    return this.request.request(argv)
  }
  getCacheKey (argv) {
    // 只支持query
    let uri = argv.url + JSON.stringify(argv.query);
    return crc32(uri)
  }
  getCache (key, ttl) {
    let val = this.caches[key];
    if (val) {
      if (ttl < 0) {
        return JSON.parse(val.value)
      }
      let now = +new Date();
      if (now < val.now + ttl * 1000) {
        return JSON.parse(val.value)
      }
      delete this.caches[key];
    }
  }
  setCache (key, ttl, name, value) {
    this.caches[key] = {
      now: +new Date(),
      ttl,
      name,
      value: JSON.stringify(value)
    };
  }
  removeCache (name) {
    let it;
    for (let cacheKey in this.caches) {
      it = this.caches[cacheKey];
      if (it.name === name) {
        delete this.caches[cacheKey];
      }
    }
  }
}

exports.Sav = Sav;
exports.EVENT_START_PAYLOADS = EVENT_START_PAYLOADS;
exports.EVENT_RESOLVE_PAYLOADS = EVENT_RESOLVE_PAYLOADS;
exports.EVENT_FINISH_PAYLOADS = EVENT_FINISH_PAYLOADS;
exports.EVENT_ERROR_PAYLOADS = EVENT_ERROR_PAYLOADS;
exports.SavVue = SavVue;
