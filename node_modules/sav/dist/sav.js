'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var fs = require('fs');
var path = require('path');

// https://github.com/nodejs/node/blob/f1653cc9b80b521ef5b129537ce1df9098bbdc1b/lib/_http_server.js#L18-L81
let STATUS_CODES = {
  100: 'Continue',
  101: 'Switching Protocols',
  102: 'Processing',
  200: 'OK', // 操作成功时使用
  201: 'Created',
  202: 'Accepted',
  203: 'Non-Authoritative Information',
  204: 'No Content',  // 不需要返回内容时使用
  205: 'Reset Content',
  206: 'Partial Content',
  207: 'Multi-Status',
  208: 'Already Reported',
  226: 'IM Used',
  300: 'Multiple Choices',
  301: 'Moved Permanently',
  302: 'Found',
  303: 'See Other',
  304: 'Not Modified',
  305: 'Use Proxy',
  307: 'Temporary Redirect',
  308: 'Permanent Redirect',
  400: 'Bad Request', // 请求参数不正确时使用
  401: 'Unauthorized', // 没有认证时使用
  402: 'Payment Required',
  403: 'Forbidden', // 没有权限时使用
  404: 'Not Found', // 资源没找到
  405: 'Method Not Allowed', // 方法不支持
  406: 'Not Acceptable',
  407: 'Proxy Authentication Required',
  408: 'Request Timeout',
  409: 'Conflict',
  410: 'Gone',
  411: 'Length Required',
  412: 'Precondition Failed',
  413: 'Payload Too Large',
  414: 'URI Too Long',
  415: 'Unsupported Media Type',
  416: 'Range Not Satisfiable',
  417: 'Expectation Failed',
  418: 'I\'m a teapot',
  421: 'Misdirected Request',
  422: 'Unprocessable Entity',
  423: 'Locked',
  424: 'Failed Dependency',
  425: 'Unordered Collection',
  426: 'Upgrade Required',
  428: 'Precondition Required',
  429: 'Too Many Requests',
  431: 'Request Header Fields Too Large',
  451: 'Unavailable For Legal Reasons',
  500: 'Internal Server Error',
  501: 'Not Implemented',
  502: 'Bad Gateway',
  503: 'Service Unavailable',
  504: 'Gateway Timeout',
  505: 'HTTP Version Not Supported',
  506: 'Variant Also Negotiates',
  507: 'Insufficient Storage',
  508: 'Loop Detected',
  509: 'Bandwidth Limit Exceeded',
  510: 'Not Extended',
  511: 'Network Authentication Required'
};

class Exception extends Error {
  constructor (message, customMessage) {
    if (message instanceof Error) {
      super(message.message);
      this.stacks = (message.stacks && message.stacks.slice()) || [];
      this.stacks.push(message);
      delete message.stacks;
      if (customMessage) {
        this.message = customMessage;
      }
    } else {
      super(message);
      this.stacks = [];
    }
  }
}

class HttpError extends Exception {
  constructor (status, message) {
    super(message || STATUS_CODES[status]);
    this.status = status;
  }
}

function unwrapExports (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var savUtil_cjs = createCommonjsModule(function (module, exports) {
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function toStringType(val) {
  return Object.prototype.toString.call(val).slice(8, -1);
}

const isArray = Array.isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}

function isString(arg) {
  return typeof arg === 'string';
}

function isFunction(arg) {
  return typeof arg === 'function';
}

function isObject(arg) {
  return toStringType(arg) === 'Object' && arg !== null;
}

function isNumber(arg) {
  return typeof arg === 'number' && !isNaN(arg);
}

function isInteger(arg) {
  return isNumber(arg) && parseInt(arg) === arg;
}

function isUndefined(arg) {
  return arg === undefined;
}

function isNull(arg) {
  return arg === null;
}

function isNan(arg) {
  return typeof arg === 'number' && isNaN(arg);
}

function isRegExp(arg) {
  return toStringType(arg) === 'RegExp';
}

function isDate(arg) {
  return toStringType(arg) === 'Date';
}

function typeValue(arg) {
  if (isNan(arg)) {
    return 'Nan';
  }
  switch (arg) {
    case undefined:
      return 'Undefined';
    case null:
      return 'Null';
    default:
      return toStringType(arg);
  }
}

const isInt = isInteger;
function isUint(arg) {
  return isInteger(arg) && arg >= 0;
}

function isAsync(func) {
  return isFunction(func) && func.constructor.name === 'AsyncFunction';
}

function isPromise(obj) {
  return obj && isFunction(obj.then);
}

let types = {
  isBoolean,
  isString,
  isNumber,
  isObject,
  isArray,
  isFunction,
  isRegExp,
  isDate,
  isNull,
  isUndefined,
  isInt,
  isUint
};

function defined(val) {
  return val !== 'undefined';
}

let probe = {
  Map: defined(typeof Map),
  Proxy: defined(typeof Proxy),
  MessageChannel: defined(typeof MessageChannel),
  localStorage: defined(typeof localStorage),
  XMLHttpRequest: defined(typeof XMLHttpRequest),
  MutationObserver: defined(typeof MutationObserver),
  FormData: defined(typeof FormData),
  window: defined(typeof window),
  document: defined(typeof document)
};

/*
 * @Description      URL解析
 * @File             url.js
 * @Auth             jetiny@hfjy.com
 */

// jsuri https://code.google.com/r/jonhwendell-jsuri/
// https://username:password@www.test.com:8080/path/index.html?this=that&some=thing#content
const REKeys = ['source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'];
const URL_RE = /^(?:(?![^:@]+:[^:@/]*@)([^:/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#/]*\.[^?#/.]+(?:[?#]|$)))*\/?)?([^?#/]*))(?:\?([^#]*))?(?:#(.*))?)/;

function parseUrl(str) {
  let _uri = {};
  let _m = URL_RE.exec(str || '');
  let _i = REKeys.length;
  while (_i--) {
    _uri[REKeys[_i]] = _m[_i] || '';
  }
  return _uri;
}

function stringifyUrl(uri) {
  let str = '';
  if (uri) {
    if (uri.host) {
      if (uri.protocol) str += uri.protocol + ':';
      str += '//';
      if (uri.user) str += uri.user + ':';
      if (uri.password) str += uri.password + '@';
      str += uri.host;
      if (uri.port) str += ':' + uri.port;
    }
    str += uri.path || '';
    if (uri.query) str += '?' + uri.query;
    if (uri.anchor) str += '#' + uri.anchor;
  }
  return str;
}

const Url = {
  parse: parseUrl,
  stringify: stringifyUrl
};

const _encode = encodeURIComponent;
const r20 = /%20/g;
const rbracket = /\[]$/;

function buildParams(prefix, obj, add) {
  if (Array.isArray(obj)) {
    // Serialize array item.
    obj.forEach(function (v, i) {
      if (rbracket.test(prefix)) {
        // Treat each array item as a scalar.
        add(prefix, v);
      } else {
        // Item is non-scalar (array or object), encode its numeric index.
        buildParams(prefix + '[' + (typeof v === 'object' ? i : '') + ']', v, add);
      }
    });
  } else if (isObject(obj)) {
    // Serialize object item.
    for (let name in obj) {
      buildParams(prefix + '[' + name + ']', obj[name], add);
    }
  } else {
    // Serialize scalar item.
    add(prefix, obj);
  }
}

// # http://stackoverflow.com/questions/1131630/the-param-inverse-function-in-javascript-jquery
// a[b]=1&a[c]=2&d[]=3&d[]=4&d[2][e]=5 <=> { a: { b: 1, c: 2 }, d: [ 3, 4, { e: 5 } ] }
function parseQuery(str, opts = {}) {
  let _querys = {};
  decodeURIComponent(str || '').replace(/\+/g, ' ')
  // (optional no-capturing & )(key)=(value)
  .replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function ($0, _name, _value) {
    if (_name) {
      let _path, _acc, _tmp, _ref;
      (_path = []).unshift(_name = _name.replace(/\[([^\]]*)]/g, function ($0, _k) {
        _path.push(_k);
        return '';
      }));
      _ref = _querys;
      for (let j = 0; j < _path.length - 1; j++) {
        _acc = _path[j];
        _tmp = _path[j + 1];
        if (!_ref[_acc]) {
          _ref[_acc] = _tmp === '' || /^[0-9]+$/.test(_tmp) ? [] : {};
        }
        _ref = _ref[_acc];
      }
      if (opts.boolval) {
        // first
        if (_value === 'true') {
          _value = true;
        } else if (_value === 'false') {
          _value = false;
        }
      } else if (opts.intval) {
        // skip "true" & "false"
        if (_tmp = parseInt(_value) === _value) {
          _value = _tmp;
        }
      }
      if ((_acc = _path[_path.length - 1]) === '') {
        _ref.push(_value);
      } else {
        _ref[_acc] = _value;
      }
    }
  });
  return _querys;
}

function stringifyQuery(query) {
  // # http://api.jquery.com/jQuery.param
  let _add = (key, value) => {
    /* jshint eqnull:true */
    _str.push(_encode(key) + '=' + (value === null || value === undefined ? '' : _encode(value)));
    // _str.push(( key ) + "=" +  (value == null ? "" : ( value )));
  };
  let _str = [];
  query || (query = {});
  for (let x in query) {
    buildParams(x, query[x], _add);
  }
  return _str.join('&').replace(r20, '+');
}

const Query = {
  parse: parseQuery,
  stringify: stringifyQuery
};

function extend() {
  // form jQuery & remove this
  let options, name, src, copy, copyIsArray, clone;
  let target = arguments[0] || {};
  let i = 1;
  let length = arguments.length;
  let deep = false;
  if (isBoolean(target)) {
    deep = target;
    target = arguments[i] || {};
    i++;
  }
  if (typeof target !== 'object' && !isFunction(target)) {
    target = {};
  }
  for (; i < length; i++) {
    options = arguments[i];
    /* jshint eqnull:true */
    if (options != null) {
      for (name in options) {
        src = target[name];
        copy = options[name];
        if (target !== copy) {
          if (deep && copy && (isObject(copy) || (copyIsArray = isArray(copy)))) {
            if (copyIsArray) {
              copyIsArray = false;
              clone = src && isArray(src) ? src : [];
            } else {
              clone = src && isObject(src) ? src : {};
            }
            target[name] = extend(deep, clone, copy);
          } else {
            target[name] = copy;
          }
        }
      }
    }
  }
  return target;
}

function clone(val) {
  if (isArray(val)) {
    return extend(true, [], val);
  } else if (isObject(val)) {
    return extend(true, {}, val);
  }
  return extend(true, [], [val])[0];
}

/**
 * 对象或数组遍历
 * @param  {Array|Object} obj      要遍历的对象
 * @param  {Function} iterator 遍历函数，统一遵循值在前的模式
 * @param  {Mixed} context  上下文对象
 * @return {Mixed}          返回要遍历的对象
 *
 * @example
 * each(['a','b'], function(val, key){
 *     if (val == 'a') {
 *         console.log(val);
 *         return false;
 *     }
 * });
 */
function each(obj, iterator, context) {
  if (obj) {
    let _length = obj.length;
    let _key;
    if (_length === +_length) {
      // array like
      for (_key = 0; _key < _length; _key++) {
        if (iterator.call(context, obj[_key], _key) === false) {
          return obj;
        }
      }
    } else {
      // object
      for (_key in obj) {
        if (obj.hasOwnProperty(_key)) {
          if (iterator.call(context, obj[_key], _key) === false) {
            return obj;
          }
        }
      }
    }
  }
  return obj;
}

function prop(target, key, value) {
  if (isObject(key)) {
    for (let name in key) {
      Object.defineProperty(target, name, { value: key[name], writable: true, configurable: true });
    }
  } else {
    Object.defineProperty(target, key, { value, writable: true, configurable: true });
  }
}

function makePropFunc(target, propName) {
  if (!target._props_) {
    prop(target, '_props_', ['_props_']);
  }
  let props = target._props_;
  return (key, value) => {
    if (isObject(key)) {
      for (let name in key) {
        Object.defineProperty(target, name, { [`${propName}`]: key[name], writable: true, configurable: true });
        props.push(name);
      }
    } else {
      let descriptor = { [`${propName}`]: value, configurable: true };
      if (propName === 'value') {
        descriptor.writable = true;
      }
      Object.defineProperty(target, key, descriptor);
      props.push(key);
    }
  };
}

function delProps(target) {
  if (target._props_) {
    target._props_.forEach(it => {
      delete target[it];
    });
  }
}

function makeProp(ctx, name) {
  if (ctx.prop) {
    return ctx.prop;
  }
  let prop = makePropFunc(ctx, 'value');
  prop.getter = makePropFunc(ctx, 'get');
  prop.setter = makePropFunc(ctx, 'set');
  if (isString(name) || isUndefined(name)) {
    prop(name || 'ctx', ctx);
  }
  prop('prop', prop);
  return prop;
}

function bindEvent(target) {
  let _events = {};
  prop(target, 'on', (event, fn) => {
    (_events[event] || (_events[event] = [])).push(fn);
  });

  prop(target, 'before', (event, fn) => {
    (_events[event] || (_events[event] = [])).unshift(fn);
  });

  prop(target, 'off', (event, fn) => {
    if (_events[event]) {
      let list = _events[event];
      if (fn) {
        let pos = list.indexOf(fn);
        if (pos !== -1) {
          list.splice(pos, 1);
        }
      } else {
        delete _events[event];
      }
    }
  });

  prop(target, 'once', (event, fn) => {
    let once = (...args) => {
      target.off(event, fn);
      fn(...args);
    };
    target.on(event, once);
  });

  prop(target, 'subscribe', (event, fn) => {
    target.on(event, fn);
    return () => {
      target.off(event, fn);
    };
  });

  prop(target, 'emit', (event, ...args) => {
    if (_events[event]) {
      let list = _events[event].slice();
      let fn;
      while (fn = list.shift()) {
        fn(...args);
      }
    }
  });
}

function unique(arr) {
  if (!Array.isArray(arr)) {
    throw new TypeError('array-unique expects an array.');
  }
  let len = arr.length;
  let i = -1;
  while (i++ < len) {
    let j = i + 1;
    for (; j < arr.length; ++j) {
      if (arr[i] === arr[j]) {
        arr.splice(j--, 1);
      }
    }
  }
  return arr;
}

function isPromiseLike(obj) {
  return !!(obj && obj.then);
}

function uuid() {
  return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();
}

function guid() {
  return new Date().getTime().toString(32) + Math.floor(Math.random() * 10000000000).toString(32) + s4();
}

function shortId() {
  let a = Math.random() + new Date().getTime();
  return a.toString(16).replace('.', '');
}

function s4() {
  return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
}

function inherits(ctor, SuperCtor, useSuper) {
  if (Object.setPrototypeOf) {
    Object.setPrototypeOf(ctor.prototype, SuperCtor.prototype);
  } else {
    ctor.prototype = new SuperCtor();
    ctor.prototype.constructor = SuperCtor;
  }
  if (useSuper) {
    ctor.super_ = SuperCtor;
  }
  return ctor;
}

function strRepeat(s, n) {
  return new Array(Math.max(n || 0, 0) + 1).join(s);
}

function noop() {}

function splitEach(str, callback, chr, context) {
  return str.split(chr || ' ').forEach(callback, context);
}

function proxy(fn, context) {
  return function () {
    fn.apply(context, arguments);
  };
}

function formatDate(fmt, date) {
  if (!fmt) fmt = 'yyyy-MM-dd';
  if (!date) {
    date = new Date();
  } else {
    date = new Date(date);
  }
  let o = {
    'M+': date.getMonth() + 1, // 月份
    'd+': date.getDate(), // 日
    'h+': date.getHours(), // 小时
    'm+': date.getMinutes(), // 分
    's+': date.getSeconds(), // 秒
    'q+': Math.floor((date.getMonth() + 3) / 3), // 季度
    'S': date.getMilliseconds() // 毫秒
  };
  if (/(y+)/.test(fmt)) {
    fmt = fmt.replace(RegExp.$1, (date.getFullYear() + '').substr(4 - RegExp.$1.length));
  }
  for (let k in o) {
    if (new RegExp('(' + k + ')').test(fmt)) {
      fmt = fmt.replace(RegExp.$1, RegExp.$1.length === 1 ? o[k] : ('00' + o[k]).substr(('' + o[k]).length));
    }
  }
  return fmt;
}

let PROMISE = Promise;
let promise = {
  resolve: PROMISE.resolve.bind(PROMISE),
  reject: PROMISE.reject.bind(PROMISE),
  all: PROMISE.all.bind(PROMISE),
  then: (fn, reject) => {
    // @NOTICE deprecated to be removed next
    return new PROMISE(fn, reject);
  }
};

function toPromise(target, methods) {
  let dist = Object.create(null);
  methods.forEach(name => {
    dist[name] = (...args) => {
      return promise.then((resolve$$1, reject) => {
        try {
          return resolve$$1(target[name].apply(target, args));
        } catch (err) {
          return reject(err);
        }
      });
    };
  });
  return dist;
}

function next() {
  let promise = Promise.resolve();
  let ret = (resolve$$1, reject) => {
    if (resolve$$1 || reject) {
      promise = promise.then(resolve$$1, reject);
    }
    return promise;
  };
  return ret;
}

function convertCase(type, str) {
  switch (type) {
    case 'pascal':
      return pascalCase(str);
    case 'camel':
      return camelCase(str);
    case 'snake':
      return snakeCase(str);
    case 'hyphen':
      return hyphenCase(str);
    default:
      return str;
  }
}

/**
 * Camelize a hyphen-delmited string.
 */
const camelCaseRE = /[-_](\w)/g;
function camelCase(str) {
  return lcfirst(str.replace(camelCaseRE, (_, c) => c ? c.toUpperCase() : ''));
}

/**
 * Capitalize a string.
 */
function ucfirst(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

/**
 * UnCapitalize a string.
 */
function lcfirst(str) {
  return str.charAt(0).toLowerCase() + str.slice(1);
}

const replaceAZRE = /([A-Z])/g;

/**
 * Hyphenate a camelCase string.
 */
function hyphenCase(str) {
  return camelCase(str).replace(replaceAZRE, '-$1').toLowerCase();
}

function snakeCase(str) {
  return camelCase(str).replace(replaceAZRE, '_$1').toLowerCase();
}

function pascalCase(str) {
  return ucfirst(camelCase(str));
}

/**
 * ajax 方法
 * @param  {Object}   opts 请求对象
 * {
 *     method:"GET",
 *     dataType:"JSON",
 *     headers:{},
 *     url:"",
 *     data:{},
 * }
 * @param  {Function} next 回调
 * @return {XMLHttpRequest}        xhr对象
 */
function ajax(opts, next) {
  let method = (opts.method || 'GET').toUpperCase();
  let dataType = (opts.dataType || 'JSON').toUpperCase();
  let timeout = opts.timeout;
  /* global XMLHttpRequest */
  let req = new XMLHttpRequest();
  let data = null;
  let isPost = method === 'POST';
  let isGet = method === 'GET';
  let isFormData = false;
  let emit = function (err, data, headers) {
    if (timeout) {
      clearTimeout(timeout);
      timeout = null;
    }
    req.onload = req.onreadystatechange = req.onerror = null;
    if (next) {
      let tmp = next;
      next = null;
      tmp(err, data, headers);
    }
  };
  if (isGet) {
    if (opts.data || opts.query) {
      let u = parseUrl(opts.url);
      let q = parseQuery(u.query);
      if (opts.query) {
        for (let x in opts.query) {
          q[x] = opts.query[x];
        }
      }
      if (opts.data) {
        for (let x in opts.data) {
          q[x] = opts.data[x];
        }
        opts.data = null;
      }
      u.query = stringifyQuery(q);
      opts.url = stringifyUrl(u);
    }
  } else if (isPost) {
    data = opts.data;
    /* global FormData */
    if (probe.FormData) {
      isFormData = data instanceof FormData;
      if (!isFormData) {
        data = stringifyQuery(data);
      }
    }
  }
  if (timeout) {
    timeout = setTimeout(function () {
      req.abort();
      emit(new Error('error_timeout'));
    }, timeout);
  }
  try {
    opts.xhr && opts.xhr(req);
    if (dataType === 'BINARY') {
      req.responseType = 'arraybuffer';
    }
    req.open(method, opts.url, true);
    if (opts.headers) {
      for (let x in opts.headers) {
        req.setRequestHeader(x, opts.headers[x]);
      }
    }
    if (isPost && !isFormData) {
      req.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
    }
    if (opts.headerOnly) {
      req.onreadystatechange = function () {
        // console.log('state', req.readyState, req);
        if (req.readyState === 2) {
          // HEADERS_RECEIVED
          let headers = parseHeaders(req.getAllResponseHeaders(), opts.camelHeaders);
          req.abort();
          emit(null, undefined, headers);
        }
      };
    }
    req.onload = function () {
      // if(req.readyState != 4) return;
      if ([200, 204, 304, 206, 0].indexOf(req.status) === -1) {
        // error
        emit(new Error('error_status_' + req.status));
      } else {
        let data = req.response;
        let parse = req.status !== 204;
        if (parse) {
          try {
            if (dataType === 'JSON') {
              data = JSON.parse(req.responseText);
            } else if (dataType === 'XML') {
              data = req.responseXML;
            } else if (dataType === 'TEXT') {
              data = req.responseText;
            } else if (dataType === 'BINARY') {
              let arrayBuffer = new Uint8Array(data);
              let str = '';
              for (let i = 0; i < arrayBuffer.length; i++) {
                str += String.fromCharCode(arrayBuffer[i]);
              }
              data = str;
            }
          } catch (err) {
            return emit(err);
          }
        }
        emit(null, data, parseHeaders(req.getAllResponseHeaders(), opts.camelHeaders));
      }
    };
    req.onerror = function (e) {
      emit(new Error('error_network'));
    };
    // 进度
    if (opts.onprogress && !opts.headerOnly) {
      req.onloadend = req.onprogress = function (e) {
        let info = {
          total: e.total,
          loaded: e.loaded,
          percent: e.total ? Math.trunc(100 * e.loaded / e.total) : 0
        };
        if (e.type === 'loadend') {
          info.percent = 100;
        } else if (e.total === e.loaded) {
          return;
        }
        if (e.total < e.loaded) {
          info.total = info.loaded;
        }
        if (info.percent === 0) {
          return;
        }
        opts.onprogress(info);
      };
    }
    req.send(data);
  } catch (e) {
    emit(e);
  }
  return req;
}

function parseHeaders(str, camelHeaders) {
  let ret = {};
  str.trim().split('\n').forEach(function (key) {
    key = key.replace(/\r/g, '');
    let arr = key.split(': ');
    let name = arr.shift().toLowerCase();
    ret[camelHeaders ? camelCase(name) : name] = arr.shift();
  });
  return ret;
}

function compose(middleware) {
  if (!Array.isArray(middleware)) throw new TypeError('Middleware stack must be an array!');
  for (const fn of middleware) {
    if (typeof fn !== 'function') throw new TypeError('Middleware must be composed of functions!');
  }
  return function (context, next) {
    // last called middleware #
    let index = -1;
    return dispatch(0);
    function dispatch(i) {
      if (i <= index) return Promise.reject(new Error('next() called multiple times'));
      index = i;
      let fn = middleware[i];
      if (i === middleware.length) fn = next;
      if (!fn) return Promise.resolve();
      try {
        return Promise.resolve(fn(context, function next() {
          return dispatch(i + 1);
        }));
      } catch (err) {
        return Promise.reject(err);
      }
    }
  };
}

let HandlePromise = class HandlePromise {
  constructor(p) {
    this.nexts = [];
    if (isFunction(p)) {
      p = new Promise(p);
    } else if (!isPromise(p)) {
      p = Promise.resolve(p);
    }
    this.next = p.then(handleResolve.bind(this), handleReject.bind(this));
  }
  then(resolve$$1, reject) {
    this.nexts.push({ resolve: resolve$$1, reject });
    return this;
  }
  catch(reject) {
    this.nexts.push({ reject });
    return this;
  }
  finally(fn) {
    this.onFinally = fn;
  }
};


function handleResolve(ret) {
  let it = this.nexts.shift();
  if (it) {
    let { resolve: resolve$$1, reject } = it;
    if (resolve$$1) {
      this.next = this.next.then(resolve$$1, reject).catch(handleReject.bind(this)).then(handleResolve.bind(this));
    }
  } else {
    if (this.onFinally) {
      this.nexts = [];
      this.onFinally();
    }
  }
}

function handleReject(err) {
  this.error = err;
  if (this.onFinally) {
    this.nexts = [];
    this.onFinally(this.error);
  }
}

exports.isArray = isArray;
exports.isBoolean = isBoolean;
exports.isString = isString;
exports.isFunction = isFunction;
exports.isObject = isObject;
exports.isNumber = isNumber;
exports.isInteger = isInteger;
exports.isUndefined = isUndefined;
exports.isNull = isNull;
exports.isNan = isNan;
exports.isRegExp = isRegExp;
exports.isDate = isDate;
exports.typeValue = typeValue;
exports.isInt = isInt;
exports.isUint = isUint;
exports.isAsync = isAsync;
exports.isPromise = isPromise;
exports.types = types;
exports.probe = probe;
exports.parseUrl = parseUrl;
exports.stringifyUrl = stringifyUrl;
exports.Url = Url;
exports.parseQuery = parseQuery;
exports.stringifyQuery = stringifyQuery;
exports.Query = Query;
exports.clone = clone;
exports.each = each;
exports.extend = extend;
exports.bindEvent = bindEvent;
exports.unique = unique;
exports.isPromiseLike = isPromiseLike;
exports.uuid = uuid;
exports.guid = guid;
exports.shortId = shortId;
exports.inherits = inherits;
exports.strRepeat = strRepeat;
exports.noop = noop;
exports.splitEach = splitEach;
exports.proxy = proxy;
exports.formatDate = formatDate;
exports.promise = promise;
exports.toPromise = toPromise;
exports.next = next;
exports.ajax = ajax;
exports.convertCase = convertCase;
exports.camelCase = camelCase;
exports.ucfirst = ucfirst;
exports.lcfirst = lcfirst;
exports.hyphenCase = hyphenCase;
exports.snakeCase = snakeCase;
exports.pascalCase = pascalCase;
exports.prop = prop;
exports.delProps = delProps;
exports.makeProp = makeProp;
exports.compose = compose;
exports.HandlePromise = HandlePromise;
});

unwrapExports(savUtil_cjs);
var savUtil_cjs_1 = savUtil_cjs.isArray;
var savUtil_cjs_3 = savUtil_cjs.isString;
var savUtil_cjs_4 = savUtil_cjs.isFunction;
var savUtil_cjs_5 = savUtil_cjs.isObject;
var savUtil_cjs_22 = savUtil_cjs.Url;
var savUtil_cjs_25 = savUtil_cjs.Query;
var savUtil_cjs_26 = savUtil_cjs.clone;
var savUtil_cjs_29 = savUtil_cjs.bindEvent;
var savUtil_cjs_45 = savUtil_cjs.convertCase;
var savUtil_cjs_51 = savUtil_cjs.pascalCase;
var savUtil_cjs_52 = savUtil_cjs.prop;

let tmplEncodeReg = /[<>&"'\x00]/g;
let tmplEncodeMap = {
  '<': '&lt;',
  '>': '&gt;',
  '&': '&amp;',
  '"': '&quot;',
  "'": '&#39;'
};

function compile (str) {
  return str.replace(/([\s'\\])(?![^%]*%\})|(?:\{%(=|#)([\s\S]+?)%\})|(\{%)|(%\})/g, function (s, p1, p2, p3, p4, p5) {
    if (p1) { // whitespace, quote and backspace in interpolation context
      return {
        '\n': '\\n',
        '\r': '\\r',
        '\t': '\\t',
        ' ': ' '
      }[s] || '\\' + s
    }
    if (p2) { // interpolation: {%=prop%}, or unescaped: {%#prop%}
      if (p2 === '=') {
        return "'\r\n+slash(" + p3 + ")+'"
      }
      return "'\r\n+(" + p3 + ")+'"
    }
    if (p4) { // evaluation start tag: {%
      return "';\r\n"
    }
    if (p5) { // evaluation end tag: %}
      return "\r\n_tmp_+='"
    }
  })
}

function slash (s) {
  return String(s || '').replace(tmplEncodeReg, (c) => tmplEncodeMap[c] || '')
}

let Func = Function;

function tmpl (str) {
  let func = new Func('state, slash', "let _tmp_=''; {_tmp_='" +
    compile(str || '') + "';}\r\n return _tmp_");
  return (state) => func(state, slash)
}

class HtmlRender {
  constructor (sav) {
    this.opts = {
      templatePath: './',
      indexTemplate: './index.html',
      errorTemplate: './error.html'
    };
    this.templateMaps = {};
    sav.shareOptions(this);
  }
  render ({ctx, argv: {error, state}, sav}) {
    let viewFunc = getTemplate(this, error);
    let html = viewFunc(state);
    if (error) {
      ctx.status = (typeof error === 'object' && error.status) || 500;
    }
    ctx.body = html;
  }
}

function getTemplate ({templateMaps, opts}, error) {
  let viewTemplate = error ? opts.errorTemplate : opts.indexTemplate;
  let viewFunc = templateMaps[viewTemplate] || (
    templateMaps[viewTemplate] = tmpl((
      fs.readFileSync(path.resolve(opts.rootPath, opts.templatePath, viewTemplate)
    ).toString())
  ));
  return viewFunc
}

class VuePayload {
  constructor (opts) {
    this.opts = {
      deepth: 2,
      Vue: null,
      router: null
    };
    this.process = null;
    this.processComponent = processComponent$1.bind(this);
    Object.assign(this.opts, opts);
  }
  setOptions (opts) {
    Object.assign(this.opts, opts);
  }
  getPayloads (route) {
    let {router, Vue} = this.opts;
    let components = router.getMatchedComponents(route);
    let arr = [];
    getComponentsDepth(Vue, components, this.opts.deepth, arr);
    let payloads = [];
    arr.reduce(this.processComponent, payloads);
    return resolvePayloads(route, payloads)
  }
}

function resolvePayloads (vueRoute, payloads) {
  return savUtil_cjs_26(payloads.reduce((routes, payload) => {
    if (savUtil_cjs_4(payload)) {
      payload = payload(vueRoute);
    }
    if (savUtil_cjs_5(payload)) {
      routes.push(payload);
    } else if (savUtil_cjs_1(payload)) {
      return routes.concat(payload.map(it => {
        if (savUtil_cjs_3(it)) {
          return {name: it}
        }
        return it
      }))
    } else if (savUtil_cjs_3(payload)) {
      routes.push({name: payload});
    }
    return routes
  }, []))
}

function processComponent$1 (payloads, component) {
  let options = typeof component === 'object' ? component : component.options;
  if (this.process) {
    this.process(options);
  }
  if (options.payload) {
    payloads.push(options.payload);
  }
  return payloads
}

function getComponentsDepth (Vue, components, depth, arr) {
  if (Array.isArray(components)) {
    for (let i = 0; i < components.length; ++i) {
      appendComponent(Vue, components[i], depth, arr);
    }
  } else {
    for (let comName in components) {
      appendComponent(Vue, components[comName], depth, arr);
    }
  }
}

function appendComponent (Vue, com, depth, arr) {
  if (savUtil_cjs_3(com)) {
    com = Vue.component(com);
  }
  if (com) {
    arr.push(com);
    if (depth && com.components) {
      getComponentsDepth(Vue, com.components, depth--, arr);
    }
  }
}

class VueRender {
  constructor (sav) {
    this.opts = {
      rootPath: '.',
      serverTemplate: './views/index.html',
      serverEntry: './server-entry.js'
    };
    sav.shareOptions(this);
    this.require = require;
    let payload = this.payload = new VuePayload();
    payload.process = processComponent;
    sav.shareOptions(payload);
  }
  async render ({ctx, argv, sav}, {route, payloads}) {
    let {vm, render, router} = this.ssr;
    let newState;
    if (payloads.length) {
      newState = await invokePayloads(sav, ctx, route, payloads);
    }
    vm.$root.$state = Object.assign(argv.state, newState);
    router.push(route);
    return new Promise((resolve$$1, reject) => {
      render.renderToString(vm, (err, html) => {
        if (err) {
          return reject(err)
        }
        html = html.replace('data-server-rendered="true"', '');
        ctx.body = html;
        resolve$$1();
      });
    })
  }
  match ({ctx, argv}) {
    if (ctx.method !== 'GET') {
      return false
    }
    let {router} = this.getRender();
    let route = router.resolve(argv.path).route;
    if (!route.matched.length) {
      return false
    }
    // 需要复制一份, 因为path不可写, 估计是被Vue冻结了
    route = Object.assign({}, route);
    let payloads = this.payload.getPayloads(route);
    return {
      route,
      payloads
    }
  }
  getRender () {
    if (!this.ssr) {
      let {opts} = this;
      let entryFile = path.resolve(opts.rootPath, opts.serverEntry);
      if (!this.serverEntry) {
        this.serverEntry = this.require(entryFile);
      }
      let {Vue, vm, router, createRenderer, renderOptions} = this.serverEntry;
      if (!this.serverTemplate) {
        this.serverTemplate = fs.readFileSync(path.resolve(opts.rootPath, opts.serverTemplate)).toString();
      }
      let template = this.serverTemplate;
      let render = createRenderer(Object.assign({template}, renderOptions));
      this.payload.setOptions({
        Vue,
        router
      });
      this.ssr = {router, render, vm, Vue};
    }
    return this.ssr
  }
}

function processComponent (options) {
  if (!options._savStriped) {
    if (options.getters) {
      let computed = options.computed || (options.computed = {});
      Object.assign(computed, mapGetters(options));
      delete options.getters;
    }
    delete options.beforeCreate;
    delete options.created;
    delete options.beforeMount;
    delete options.mounted;
    delete options.beforeUpdate;
    delete options.updated;
    delete options.activated;
    delete options.deactivated;
    delete options.beforeDestroy;
    delete options.destroyed;

    delete options.watch;

    delete options.beforeRouteEnter;
    delete options.beforeRouteUpdate;
    delete options.beforeRouteLeave;
    options._savStriped = true;
  }
}

function mapGetters ({getters}) {
  let res = {};
  normalizeMap(getters).forEach(function (ref) {
    let key = ref.key;
    let val = ref.val;
    res[key] = savUtil_cjs_4(val) ? function mappedGetter () { // function(state){}
      return val.call(this, this.$root.$state)
    } : function mappedGetter () {
      return this.$root.$state[val]
    };
  });
  return res
}

function normalizeMap (map) {
  return Array.isArray(map) ? map.map(key => {
    return {
      key: key,
      val: key
    }
  }) : Object.keys(map).map(key => {
    return {
      key: key,
      val: map[key]
    }
  })
}

function invokePayloads (sav, ctx, vueRoute, payloads) {
  let states = [];
  let routes = payloads.filter((it) => {
    if (savUtil_cjs_5(it)) {
      if (it.sav) {
        if (it.sav !== sav.name) { // 跨sav的情况
          return false
        }
      }
      if (sav.resolvePayload(it, vueRoute)) {
        if (it.state) {
          states.push(it.state);
          return false
        }
        // 只处理GET请求
        if (it.route.method !== 'GET') {
          return false
        }
        // 跳过当前路由
        return it.path !== vueRoute.path
      }
    }
  });
  return Promise.all(routes.map((route) => sav.invokePayload(ctx, route)))
    .then((args) => {
      args = states.concat(args);
      return args.length ? Object.assign.apply({}, args) : {}
    })
}

var isarray = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

/**
 * Expose `pathToRegexp`.
 */
var pathToRegexp_1 = pathToRegexp;
var parse_1 = parse;
var compile_1 = compile$1;
var tokensToFunction_1 = tokensToFunction;
var tokensToRegExp_1 = tokensToRegExp;

/**
 * The main path matching regexp utility.
 *
 * @type {RegExp}
 */
var PATH_REGEXP = new RegExp([
// Match escaped characters that would otherwise appear in future matches.
// This allows the user to escape special characters that won't transform.
'(\\\\.)',
// Match Express-style parameters and un-named parameters with a prefix
// and optional suffixes. Matches appear as:
//
// "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?", undefined]
// "/route(\\d+)"  => [undefined, undefined, undefined, "\d+", undefined, undefined]
// "/*"            => ["/", undefined, undefined, undefined, undefined, "*"]
'([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))'].join('|'), 'g');

/**
 * Parse a string for the raw tokens.
 *
 * @param  {string}  str
 * @param  {Object=} options
 * @return {!Array}
 */
function parse(str, options) {
  var tokens = [];
  var key = 0;
  var index = 0;
  var path$$1 = '';
  var defaultDelimiter = options && options.delimiter || '/';
  var res;

  while ((res = PATH_REGEXP.exec(str)) != null) {
    var m = res[0];
    var escaped = res[1];
    var offset = res.index;
    path$$1 += str.slice(index, offset);
    index = offset + m.length;

    // Ignore already escaped sequences.
    if (escaped) {
      path$$1 += escaped[1];
      continue;
    }

    var next = str[index];
    var prefix = res[2];
    var name = res[3];
    var capture = res[4];
    var group = res[5];
    var modifier = res[6];
    var asterisk = res[7];

    // Push the current path onto the tokens.
    if (path$$1) {
      tokens.push(path$$1);
      path$$1 = '';
    }

    var partial = prefix != null && next != null && next !== prefix;
    var repeat = modifier === '+' || modifier === '*';
    var optional = modifier === '?' || modifier === '*';
    var delimiter = res[2] || defaultDelimiter;
    var pattern = capture || group;

    tokens.push({
      name: name || key++,
      prefix: prefix || '',
      delimiter: delimiter,
      optional: optional,
      repeat: repeat,
      partial: partial,
      asterisk: !!asterisk,
      pattern: pattern ? escapeGroup(pattern) : asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?'
    });
  }

  // Match any characters still remaining.
  if (index < str.length) {
    path$$1 += str.substr(index);
  }

  // If the path exists, push it onto the end.
  if (path$$1) {
    tokens.push(path$$1);
  }

  return tokens;
}

/**
 * Compile a string to a template function for the path.
 *
 * @param  {string}             str
 * @param  {Object=}            options
 * @return {!function(Object=, Object=)}
 */
function compile$1(str, options) {
  return tokensToFunction(parse(str, options));
}

/**
 * Prettier encoding of URI path segments.
 *
 * @param  {string}
 * @return {string}
 */
function encodeURIComponentPretty(str) {
  return encodeURI(str).replace(/[\/?#]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase();
  });
}

/**
 * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.
 *
 * @param  {string}
 * @return {string}
 */
function encodeAsterisk(str) {
  return encodeURI(str).replace(/[?#]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase();
  });
}

/**
 * Expose a method for transforming tokens into the path function.
 */
function tokensToFunction(tokens) {
  // Compile all the tokens into regexps.
  var matches = new Array(tokens.length);

  // Compile all the patterns before compilation.
  for (var i = 0; i < tokens.length; i++) {
    if (typeof tokens[i] === 'object') {
      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$');
    }
  }

  return function (obj, opts) {
    var path$$1 = '';
    var data = obj || {};
    var options = opts || {};
    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent;

    for (var i = 0; i < tokens.length; i++) {
      var token = tokens[i];

      if (typeof token === 'string') {
        path$$1 += token;

        continue;
      }

      var value = data[token.name];
      var segment;

      if (value == null) {
        if (token.optional) {
          // Prepend partial segment prefixes.
          if (token.partial) {
            path$$1 += token.prefix;
          }

          continue;
        } else {
          throw new TypeError('Expected "' + token.name + '" to be defined');
        }
      }

      if (isarray(value)) {
        if (!token.repeat) {
          throw new TypeError('Expected "' + token.name + '" to not repeat, but received `' + JSON.stringify(value) + '`');
        }

        if (value.length === 0) {
          if (token.optional) {
            continue;
          } else {
            throw new TypeError('Expected "' + token.name + '" to not be empty');
          }
        }

        for (var j = 0; j < value.length; j++) {
          segment = encode(value[j]);

          if (!matches[i].test(segment)) {
            throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '", but received `' + JSON.stringify(segment) + '`');
          }

          path$$1 += (j === 0 ? token.prefix : token.delimiter) + segment;
        }

        continue;
      }

      segment = token.asterisk ? encodeAsterisk(value) : encode(value);

      if (!matches[i].test(segment)) {
        throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but received "' + segment + '"');
      }

      path$$1 += token.prefix + segment;
    }

    return path$$1;
  };
}

/**
 * Escape a regular expression string.
 *
 * @param  {string} str
 * @return {string}
 */
function escapeString(str) {
  return str.replace(/([.+*?=^!:${}()[\]|\/\\])/g, '\\$1');
}

/**
 * Escape the capturing group by escaping special characters and meaning.
 *
 * @param  {string} group
 * @return {string}
 */
function escapeGroup(group) {
  return group.replace(/([=!:$\/()])/g, '\\$1');
}

/**
 * Attach the keys as a property of the regexp.
 *
 * @param  {!RegExp} re
 * @param  {Array}   keys
 * @return {!RegExp}
 */
function attachKeys(re, keys) {
  re.keys = keys;
  return re;
}

/**
 * Get the flags for a regexp from the options.
 *
 * @param  {Object} options
 * @return {string}
 */
function flags(options) {
  return options.sensitive ? '' : 'i';
}

/**
 * Pull out keys from a regexp.
 *
 * @param  {!RegExp} path
 * @param  {!Array}  keys
 * @return {!RegExp}
 */
function regexpToRegexp(path$$1, keys) {
  // Use a negative lookahead to match only capturing groups.
  var groups = path$$1.source.match(/\((?!\?)/g);

  if (groups) {
    for (var i = 0; i < groups.length; i++) {
      keys.push({
        name: i,
        prefix: null,
        delimiter: null,
        optional: false,
        repeat: false,
        partial: false,
        asterisk: false,
        pattern: null
      });
    }
  }

  return attachKeys(path$$1, keys);
}

/**
 * Transform an array into a regexp.
 *
 * @param  {!Array}  path
 * @param  {Array}   keys
 * @param  {!Object} options
 * @return {!RegExp}
 */
function arrayToRegexp(path$$1, keys, options) {
  var parts = [];

  for (var i = 0; i < path$$1.length; i++) {
    parts.push(pathToRegexp(path$$1[i], keys, options).source);
  }

  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options));

  return attachKeys(regexp, keys);
}

/**
 * Create a path regexp from string input.
 *
 * @param  {string}  path
 * @param  {!Array}  keys
 * @param  {!Object} options
 * @return {!RegExp}
 */
function stringToRegexp(path$$1, keys, options) {
  return tokensToRegExp(parse(path$$1, options), keys, options);
}

/**
 * Expose a function for taking tokens and returning a RegExp.
 *
 * @param  {!Array}          tokens
 * @param  {(Array|Object)=} keys
 * @param  {Object=}         options
 * @return {!RegExp}
 */
function tokensToRegExp(tokens, keys, options) {
  if (!isarray(keys)) {
    options = /** @type {!Object} */keys || options;
    keys = [];
  }

  options = options || {};

  var strict = options.strict;
  var end = options.end !== false;
  var route = '';

  // Iterate over the tokens and create our regexp string.
  for (var i = 0; i < tokens.length; i++) {
    var token = tokens[i];

    if (typeof token === 'string') {
      route += escapeString(token);
    } else {
      var prefix = escapeString(token.prefix);
      var capture = '(?:' + token.pattern + ')';

      keys.push(token);

      if (token.repeat) {
        capture += '(?:' + prefix + capture + ')*';
      }

      if (token.optional) {
        if (!token.partial) {
          capture = '(?:' + prefix + '(' + capture + '))?';
        } else {
          capture = prefix + '(' + capture + ')?';
        }
      } else {
        capture = prefix + '(' + capture + ')';
      }

      route += capture;
    }
  }

  var delimiter = escapeString(options.delimiter || '/');
  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter;

  // In non-strict mode we allow a slash at the end of match. If the path to
  // match already ends with a slash, we remove it for consistency. The slash
  // is valid at the end of a path match, not in the middle. This is important
  // in non-ending mode, where "/test/" shouldn't match "/test//route".
  if (!strict) {
    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?';
  }

  if (end) {
    route += '$';
  } else {
    // In non-ending mode, we need the capturing groups to match as much as
    // possible by using a positive lookahead to the end or next path segment.
    route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)';
  }

  return attachKeys(new RegExp('^' + route, flags(options)), keys);
}

/**
 * Normalize the given path string, returning a regular expression.
 *
 * An empty array can be passed in for the keys, which will hold the
 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
 * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
 *
 * @param  {(string|RegExp|Array)} path
 * @param  {(Array|Object)=}       keys
 * @param  {Object=}               options
 * @return {!RegExp}
 */
function pathToRegexp(path$$1, keys, options) {
  if (!isarray(keys)) {
    options = /** @type {!Object} */keys || options;
    keys = [];
  }

  options = options || {};

  if (path$$1 instanceof RegExp) {
    return regexpToRegexp(path$$1, /** @type {!Array} */keys);
  }

  if (isarray(path$$1)) {
    return arrayToRegexp( /** @type {!Array} */path$$1, /** @type {!Array} */keys, options);
  }

  return stringToRegexp( /** @type {string} */path$$1, /** @type {!Array} */keys, options);
}

pathToRegexp_1.parse = parse_1;
pathToRegexp_1.compile = compile_1;
pathToRegexp_1.tokensToFunction = tokensToFunction_1;
pathToRegexp_1.tokensToRegExp = tokensToRegExp_1;

class Router {
  constructor (opts) {
    this.opts = {
      prefix: '',
      caseType: 'camel',
      sensitive: true
    };
    savUtil_cjs_29(this);
    opts && this.setOptions(opts);
    this.modals = {};
    this.actionRoutes = createMethods();
    this.modalRoutes = [];
  }
  setOptions (opts) {
    Object.assign(this.opts, opts);
  }
  declare (routeModals) {
    for (let modalName in routeModals) {
      this.declareModal(modalName, routeModals[modalName]);
    }
  }
  declareModal (modalName, modal) {
    this.removeModal(modalName);
    createModalRoute(this, modalName, modal);
  }
  removeModal (modalName) {
    if (this.modals[modalName]) {
      return removeModal(this, modalName)
    }
  }
  matchRoute (path$$1, method) {
    if (method === 'ANY') {
      for (let submethod of methods) {
        let ret = this.matchRoute(path$$1, submethod);
        if (ret) {
          return ret
        }
      }
    }
    if (methods.indexOf(method) === -1) {
      return
    }
    let uri = savUtil_cjs_22.parse(path$$1);
    path$$1 = stripPrefix(uri.path, this.opts.prefix);
    let ret = {
      path: path$$1
    };
    // 顶级路由
    for (let route of this.actionRoutes[method]) {
      if (matchRoute(route, path$$1, ret)) {
        ret.query = uri.query ? savUtil_cjs_25.parse(uri.query) : {};
        return ret
      }
    }
    for (let route of this.modalRoutes) {
      // 模块路由
      if (matchRoute(route, path$$1)) {
        for (let subRoute of route.routes[method]) {
          // 子级路由
          if (matchRoute(subRoute, path$$1, ret)) {
            ret.query = uri.query ? savUtil_cjs_25.parse(uri.query) : {};
            return ret
          }
        }
      }
    }
  }
}

const methods = ['GET', 'POST', 'PUT', 'DELETE', 'PATCH'];

function createMethods () {
  let ret = {};
  methods.forEach((name) => {
    ret[name] = [];
  });
  return ret
}

function matchRoute (route, path$$1, ret) {
  let mat = path$$1.match(route.regexp);
  if (mat) {
    if (ret) {
      ret.route = route;
      let {keys} = route;
      let params = ret.params = {};
      for (let i = 1, len = mat.length; i < len; ++i) {
        const key = keys[i - 1];
        if (key) {
          const val = typeof mat[i] === 'string' ? decodeURIComponent(mat[i]) : mat[i];
          params[key.name] = val;
        }
      }
    }
    return true
  }
}

function stripPrefix (src, prefix) {
  if (prefix) {
    let pos = src.indexOf(prefix);
    if (pos === 0 || ((pos === 1) && src[0] === '/')) {
      src = src.substr(pos + prefix.length, src.length);
      if (src[0] !== '/') {
        src = '/' + src;
      }
      return src
    }
  }
  return src
}

function removeModal (router, modalName) {
  let modal = router.modals[modalName];
  delete router.modals[modalName];
  router.modalRoutes = router.modalRoutes.filter((route) => route.modal !== modal);
  let actionRoutes = router.actionRoutes;
  methods.forEach((method) => {
    actionRoutes[method] = actionRoutes[method].filter((route) => route.modal !== modal);
  });
  router.emit('removeModal', modal);
  return modal
}

function createModalRoute (router, modalName, modal) {
  let modalRoute = createRoute(router, modalName, modal);
  modalRoute.routes = createMethods();
  router.emit('declareModal', modalRoute);
  for (let actionName in modal.routes) {
    createRoute(router, actionName, modal.routes[actionName], modalRoute);
  }
  router.modals[modalName] = modal;
}

function createRoute (router, name, refer, modalRoute) {
  refer.name = name;
  let route = {};
  let modal = modalRoute ? modalRoute.modal : refer;
  savUtil_cjs_52(route, 'modal', modal);
  let {caseType, sensitive} = router.opts;
  let path$$1 = convertPath(refer.path, caseType, name);
  if (!modalRoute) { // modal总是以''开始
    path$$1 = normalPath((refer.prefix || '') + '/' + path$$1);
    route.name = savUtil_cjs_51(name);
    router.modalRoutes.push(route);
  } else { // action
    route.name = modalRoute.name + savUtil_cjs_51(name);
    let method = route.method = (refer.method || 'GET');
    let isRelative = path$$1[0] !== '/';
    if (isRelative) { // 相对路由
      path$$1 = modalRoute.path + '/' + path$$1;
    }
    if (isRelative) {
      modalRoute.routes[method].push(route);
    } else {
      router.actionRoutes[method].push(route);
    }
    route.actionName = `${modal.name}.${name}`;
    savUtil_cjs_52(route, 'action', refer);
  }
  route.path = normalPath('/' + path$$1);
  route.keys = [];
  route.regexp = pathToRegexp_1(route.path, route.keys, {
    sensitive,
    end: !!modalRoute
  });
  route.compile = pathToRegexp_1.compile(route.path, {
    sensitive,
    end: !!modalRoute
  });
  router.emit('declareAction', route);
  return route
}

function convertPath (path$$1, caseType, name) {
  if (!savUtil_cjs_3(path$$1)) {
    path$$1 = savUtil_cjs_45(caseType, name);
  }
  return path$$1
}

function normalPath (path$$1) {
  return path$$1.replace(/\/+/g, '/')
}

class ModalAction {
  constructor (opts) {
    this.opts = {};
    this.setOptions(opts);
    this.modals = {};
    this.actions = {};
  }
  setOptions (opts) {
    Object.assign(this.opts, opts);
  }
  declare (modals) {
    for (let modalName in modals) {
      this.declareModal(modalName, modals[modalName]);
    }
  }
  declareModal (modalName, modal) {
    this.removeModal(modalName);
    let actions = this.modals[modalName] = classToObject(modal);
    for (let actionName in actions) {
      this.actions[`${modalName}.${actionName}`] = actions[actionName];
    }
  }
  removeModal (modalName) {
    if (this.modals[modalName]) {
      delete this.modals[modalName];
      modalName = modalName + '.';
      for (let actionName in this.actions) {
        if (actionName.indexOf(modalName) === 0) {
          delete this.actions[actionName];
        }
      }
    }
  }
  getAction (actionName) {
    return this.actions[actionName]
  }
}

const skips = ['constructor'];

function classToObject (target) {
  if (savUtil_cjs_4(target)) {
    let proto = target.prototype;
    return Object.getOwnPropertyNames(proto).reduce((tar, it) => {
      if (!~skips.indexOf(it) && typeof savUtil_cjs_4(proto[it])) {
        tar[it] = proto[it];
      }
      return tar
    }, {})
  } else {
    return target
  }
}

var savSchema_cjs = createCommonjsModule(function (module, exports) {
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });



let SchemaBase = class SchemaBase {
  constructor(schema, opts) {
    this.opts = opts;
    this.schema = schema;
  }
  get id() {
    return this.opts.id;
  }
  get name() {
    return this.opts.name;
  }
  get ref() {
    return this.schema.getRef(this);
  }
};

/*
{
  name: 'String',
  check (val) {},
  parse (val) {},
  default: String,
}
 */

let SchemaType = class SchemaType extends SchemaBase {
  parse(val) {
    return this.opts.parse(val);
  }
  check(val) {
    return this.opts.check(val);
  }
  create(val) {
    if (!savUtil_cjs.isUndefined(val)) {
      return this.parse(val);
    }
    let factory = this.opts.default;
    if (savUtil_cjs.isFunction(factory)) {
      return factory();
    }
    return factory;
  }
};

/* eslint {"eqeqeq": 0} */

/*
{
  name: 'Sex',
  *strict: false,
  enums: [
    {key: 'male', value: 1},
    {key: 'female', value: 2},
  ]
}
 */

let SchemaEnum = class SchemaEnum extends SchemaBase {
  check(val) {
    let { strict, enums } = this.opts;
    let len = enums.length;
    while (len) {
      let it = enums[--len];
      if (strict) {
        if (it.value === val || it.key == val) {
          return true;
        }
      } else {
        if (it.value == val || it.key == val) {
          return true;
        }
      }
    }
  }
  create(val) {
    if (!savUtil_cjs.isUndefined(val)) {
      return val;
    }
    return this.opts.enums[0].value;
  }
  parse(val) {
    if (savUtil_cjs.isUndefined(val)) {
      return;
    }
    let { enums } = this.opts;
    let len = enums.length;
    while (len) {
      let it = enums[--len];
      if (it.value == val) {
        return it.value;
      }
      if (it.key == val) {
        return it.key;
      }
    }
  }
  getEnum(key, val) {
    for (let it of this.opts.enums) {
      if (it[key] === val) {
        return it;
      }
    }
  }
  key(val) {
    return this.getEnum('value', val).key;
  }
  value(val) {
    return this.getEnum('key', val).value;
  }
};
let SchemaControl = class SchemaControl extends SchemaBase {
  check(obj, opts) {
    return this.validate(obj, opts || {});
  }
  checkThen(obj, opts) {
    return Promise.resolve().then(() => this.check(obj, opts));
  }
  extract(obj, opts = {}) {
    opts.extract = true;
    return this.validate(obj, opts);
  }
  extractThen(obj, opts) {
    return Promise.resolve().then(() => this.extract(obj, opts));
  }
};


function stringVal(val) {
  if (savUtil_cjs.isNumber(val) || savUtil_cjs.isBoolean(val)) {
    return String(val);
  }
  return val;
}

function boolVal(val) {
  if (savUtil_cjs.isNumber(val)) {
    return Boolean(val);
  }
  if (savUtil_cjs.isString(val)) {
    if (val === 'true' || val === 'on') {
      return true;
    }
    return false;
  }
  return val;
}

function numberVal(val) {
  if (savUtil_cjs.isBoolean(val)) {
    return Number(val);
  } else if (savUtil_cjs.isString(val)) {
    let it = parseFloat(val);
    if (isNaN(it)) {
      if (val === 'true' || val === 'on') {
        return 1;
      }
      return 0;
    }
    return it;
  }
  return val;
}

function arrayVal(val) {
  if (savUtil_cjs.isString(val)) {
    if (val[0] === '[' && val[val.length - 1] === ']') {
      try {
        return JSON.parse(val);
      } catch (err) {
        return val;
      }
    } else if (val.indexOf(',') !== -1) {
      return val.split(',');
    }
  }
  return val;
}

function objectVal(val) {
  if (savUtil_cjs.isString(val)) {
    if (val[0] === '{' && val[val.length - 1] === '}') {
      try {
        return JSON.parse(val);
      } catch (err) {
        return val;
      }
    }
  }
  return val;
}

let rangs = {
  // 0xFF byte 的取值范围为-128~127，占用1个字节 -2的7次方到2的7次方-1
  Int8: [-128, 127],
  UInt8: [0, 255],
  Byte: [-128, 255],
  // 0xFFFF short 的取值范围为-32768~32767，占用2个字节 -2的15次方到2的15次方-1
  Int16: [-32768, 32767],
  UInt16: [0, 65535],
  Short: [-32768, 65535],
  // 0xFFFFFFFF int的取值范围为-2147483648~2147483647，占用4个字节 -2的31次方到2的31次方-1
  Int32: [-2147483648, 2147483647],
  UInt32: [0, 4294967295],
  Integer: [-2147483648, 4294967295],
  // -0X1FFFFFFFFFFFFF ~ 0X1FFFFFFFFFFFFF, Number.MAX_SAFE_INTEGER ~ Number.MAX_SAFE_INTEGER
  // 占用8个字节 -2的53次方到2的53次方-1 Math.pow(2, 53)
  Long: [-9007199254740991, 9007199254740991]
};

function isNatural(val) {
  return savUtil_cjs.isNumber(val) && parseInt(val) === val;
}

function isStringObject(val) {
  if (savUtil_cjs.isString(val)) {
    return true;
  }
  return typeof val === 'object' && val !== null && val.constructor.name === 'ObjectID';
}

let types = [{ name: String, check: isStringObject, parse: stringVal }, { name: Number, check: savUtil_cjs.isNumber, parse: numberVal }, { name: Boolean, check: savUtil_cjs.isBoolean, parse: boolVal }, { name: Array, check: savUtil_cjs.isArray, parse: arrayVal }, { name: Object, check: savUtil_cjs.isObject, parse: objectVal }].map(it => {
  it.default = it.name;
  it.name = it.name.name;
  return it;
});

Object.keys(rangs).forEach(name => {
  let [min, max] = rangs[name];
  types.push({
    name,
    default: Number,
    check: val => {
      return isNatural(val) && val >= min && val <= max;
    },
    parse: numberVal,
    min,
    max
  });
});

function registerTypes(schema) {
  types.forEach(it => schema.registerType(it));
}

let errors = {
  type: 'Value [{value}] is not of [{type}] type',
  require: 'Field [{field}] not found',
  empty: 'Field [{field}] can not be empty',
  check: 'Field [{field}] can not matched [{rule}] rule',
  rule: 'Rule [{rule}] not found',
  eql: 'Fields [{field}] and [{field_eql}] not equal',
  regexp: 'Can not parse RegExp [{regexp}]'
};

let SchemaTypeError = class SchemaTypeError extends Error {
  constructor(type, value, message = errors.type) {
    let val = String(value);
    super(message.replace('{type}', type).replace('{value}', val));
    this.type = type;
    this.value = value;
  }
};
let SchemaRequiredError = class SchemaRequiredError extends Error {
  constructor(field, message = errors.require) {
    super(message.replace('{field}', field));
    this.field = field;
  }
};
let SchemaEmptyError = class SchemaEmptyError extends Error {
  constructor(field, message = errors.empty) {
    super(message.replace('{field}', field));
    this.field = field;
  }
};
let SchemaCheckedError = class SchemaCheckedError extends Error {
  constructor(field, rule, message = errors.check) {
    super(message.replace('{field}', field).replace('{rule}', rule));
    this.field = field;
    this.rule = rule;
  }
};
let SchemaEqlError = class SchemaEqlError extends Error {
  constructor(field, fieldEql, message = errors.eql) {
    super(message.replace('{field}', field).replace('{field_eql}', fieldEql));
    this.field = field;
    this.field_eql = fieldEql;
  }
};
let SchemaNoRuleError = class SchemaNoRuleError extends Error {
  constructor(rule, message = errors.rule) {
    super(message.replace('{rule}', rule));
    this.rule = rule;
  }
};
let SchemaInvalidRegexpError = class SchemaInvalidRegexpError extends Error {
  constructor(regexp, message = errors.regexp) {
    super(message.replace('{regexp}', regexp));
    this.regexp = regexp;
  }
};


function setErrors(errs) {
  Object.assign(errors, errs);
}

/*
{
  name: 'Users',
  list: 'String'
}
 */

let SchemaList = class SchemaList extends SchemaControl {
  parse(val) {
    return arrayVal(val);
  }
  create(value) {
    value = this.parse(value);
    if (savUtil_cjs.isArray(value)) {
      let ref = this.ref;
      return value.map(it => ref.create(it));
    }
    return [];
  }
  validate(obj, opts) {
    let { ref } = this;
    let { name } = this.opts;
    let { extract, replace } = opts;
    let val = this.parse(obj);
    if (!savUtil_cjs.isArray(val)) {
      throw new SchemaTypeError(name || 'list', val);
    }
    let ret = [];
    for (let i = 0, l = val.length; i < l; ++i) {
      try {
        let newIt = checkValue(val[i], opts, ref);
        if (extract) {
          ret.push(!savUtil_cjs.isUndefined(newIt) ? val[i] : newIt);
        }
        if (replace) {
          if (!savUtil_cjs.isUndefined(newIt)) {
            val[i] = newIt;
          }
        }
      } catch (err) {
        (err.keys || (err.keys = [])).unshift(i);
        throw err;
      }
    }
    return extract ? ret : obj;
  }
};


function checkValue(val, opts, ref) {
  if (ref.parse) {
    val = ref.parse(val);
  }
  if (ref.validate) {
    return ref.validate(val, opts);
  }
  if (!ref.check(val)) {
    throw new SchemaTypeError(ref.name, val);
  }
  return val;
}

/*
{
  name: 'userName',
  type: String,
  *nullable: true,
  *empty: false,
  *required: false,
  *trim: false
  *eql: 'userName2'
}
 */

let SchemaField = class SchemaField extends SchemaBase {
  create(val) {
    let ret = this.ref.create(val);
    return ret;
  }
  validate(obj, opts) {
    let { ref } = this;
    let { name, nullable, empty, eql, optional, message, checks } = this.opts;
    if (optional && !(name in obj)) {
      return;
    }
    if (nullable && savUtil_cjs.isNull(obj[name])) {
      return;
    }
    try {
      if (!(name in obj)) {
        throw new SchemaRequiredError(name);
      }
      let val = obj[name];
      if (!empty && !savUtil_cjs.isNull(val)) {
        if (val === '') {
          throw new SchemaEmptyError(name);
        }
      }
      if (eql) {
        let eqlVal = obj[eql];
        if (eqlVal !== val) {
          throw new SchemaEqlError(name, eql);
        }
      }
      let rule = this.schema.applyChecks(val, checks);
      if (rule) {
        throw new SchemaCheckedError(name, rule[0]);
      }
      val = checkValue$1(val, opts, ref);
      return val;
    } catch (err) {
      if (message) {
        err.message = message;
      }
      throw err;
    }
  }
};


function checkValue$1(val, opts, ref) {
  if (ref.parse) {
    val = ref.parse(val);
  }
  if (ref.validate) {
    return ref.validate(val, opts);
  }
  if (!ref.check(val)) {
    throw new SchemaTypeError(ref.name, val);
  }
  return val;
}

let SchemaRefer = class SchemaRefer extends SchemaControl {
  create(value) {
    return this.ref.create(value);
  }
  validate(obj, opts) {
    return this.ref.validate(obj, opts);
  }
};
let SchemaStruct = class SchemaStruct extends SchemaControl {
  create(obj) {
    let isObj = savUtil_cjs.isObject(obj);
    let struct = isObj ? obj : {};
    this.fields.forEach(it => {
      struct[it.name] = isObj && it.name in obj ? it.create(obj[it.name]) : it.create();
    });
    return struct;
  }
  validate(obj, opts) {
    try {
      let { extract, replace } = opts;
      let ret = extract ? {} : obj;
      for (let field of this.fields) {
        try {
          let val = field.validate(obj, opts);
          if (!savUtil_cjs.isUndefined(val)) {
            if (extract || replace) {
              ret[field.name] = val;
            }
          }
        } catch (err) {
          (err.keys || (err.keys = [])).unshift(field.name);
          throw err;
        }
      }
      return ret;
    } catch (err) {
      if (err.keys) {
        err.path = err.keys.join('.');
      }
      throw err;
    }
  }
};
let SchemaCheck = class SchemaCheck {
  constructor(schema, opts) {
    this.opts = opts;
    this.schema = schema;
  }
  get name() {
    return this.opts.name;
  }
  get alias() {
    return this.opts.alias;
  }
  check(value, args) {
    return this.opts.check(value, args);
  }
  get argc() {
    return this.opts.argc || 1;
  }
};

// 数字大小

function gt(value, [, arg1]) {
  return value > arg1;
}

function gte(value, [, arg1]) {
  return value >= arg1;
}

function lt(value, [, arg1]) {
  return value < arg1;
}

function lte(value, [, arg1]) {
  return value <= arg1;
}

// 包含
function $in(value, argv) {
  return argv.indexOf(value) > 0;
}

function nin(value, argv) {
  return argv.indexOf(value) <= 0;
}

// 字符串或数组长度
function lgt(value, argv) {
  return gt(value.length, argv);
}

function lgte(value, argv) {
  return gte(value.length, argv);
}

function llt(value, argv) {
  return lt(value.length, argv);
}

function llte(value, argv) {
  return lte(value.length, argv);
}

let regexpMaps = {};
// 正则表达式
function re(value, [, regexp]) {
  if (typeof regexp === 'string') {
    if (!regexpMaps[regexp]) {
      regexpMaps[regexp] = toRegExp(regexp);
    }
  }
  let ref = regexpMaps[regexp] || regexp;
  return ref.test(value);
}

function nre(value, argv) {
  return !re(value, argv);
}

// https://github.com/borela/str-to-regexp/blob/master/src/index.js
const COMPLEX_BEGIN = /^\s*\//;
const COMPLEX_REGEX = /^\s*\/(.+)\/(\w*)\s*$/;

function parseWithFlags(fullPattern) {
  try {
    let [, pattern, flags] = fullPattern.match(COMPLEX_REGEX);
    return flags ? new RegExp(pattern, flags) : new RegExp(pattern);
  } catch (e) {
    throw new SchemaInvalidRegexpError(fullPattern);
  }
}

function toRegExp(pattern) {
  return COMPLEX_BEGIN.test(pattern) ? parseWithFlags(pattern) : new RegExp(pattern);
}

let checks = [{ name: 'gt', alias: '>', check: gt }, { name: 'gte', alias: '>=', check: gte }, { name: 'lt', alias: '<', check: lt }, { name: 'lte', alias: '<=', check: lte }, { name: 'in', check: $in }, { name: 'nin', check: nin }, { name: 'lgt', check: lgt }, { name: 'lgte', check: lgte }, { name: 'llt', check: llt }, { name: 'llte', check: llte }, { name: 're', check: re }, { name: 'nre', check: nre }];

function registerChecks(schema) {
  checks.forEach(it => schema.registerCheck(it));
}

const SCHEMA_TYPE = 1;
const SCHEMA_ENUM = 2;
const SCHEMA_STURCT = 3;
const SCHEMA_LIST = 4;
const SCHEMA_REFER = 5;
const SCHEMA_FIELD = 6;

let Schema = class Schema {
  constructor(opts) {
    this.opts = Object.assign({
      strict: true
    }, opts);
    this.idMap = {};
    this.nameMap = {};
    this.checks = {};
    registerTypes(this);
    registerChecks(this);
  }
  declare(data, opts = {}) {
    if (savUtil_cjs.isArray(data)) {
      return data.map(it => this.declare(it, opts));
    } else if (savUtil_cjs.isObject(data)) {
      let ret = createSchema(this, data, opts);
      return ret;
    }
  }
  load(data, opts = {}) {
    // 从suite加载
    ['fields', 'enums', 'lists', 'structs', 'schemas'].forEach(it => {
      if (data[it]) {
        this.declare(data[it], opts);
      }
    });
  }
  registerType(opts) {
    let ret = new SchemaType(this, opts);
    ret.schemaType = SCHEMA_TYPE;
    exportSchema(this, ret);
    return ret;
  }
  registerCheck(opts) {
    let ret = new SchemaCheck(this, opts);
    let { name, alias } = ret;
    this.checks[name] = ret;
    if (alias) {
      this.checks[alias] = ret;
    }
    return ret;
  }
  applyChecks(value, rules) {
    if (savUtil_cjs.isArray(rules)) {
      for (let rule of rules) {
        let [name] = rule;
        let ruller = this.checks[name];
        if (ruller) {
          if (!ruller.check(value, rule)) {
            return rule;
          }
        } else {
          throw new SchemaNoRuleError(name);
        }
      }
    }
  }
  getRef(ret) {
    let { opts } = ret;
    switch (ret.schemaType) {
      case SCHEMA_REFER:
        return this.idMap[opts.refer] || this.nameMap[opts.refer];
      case SCHEMA_LIST:
        return this.idMap[opts.list] || this.nameMap[opts.list];
      case SCHEMA_FIELD:
        return this.idMap[opts.type] || this.nameMap[opts.type];
    }
  }
};


function createSchema(schema, data, opts) {
  let { enums, props, refer, list, type, refs } = data;
  if (refs) {
    if (savUtil_cjs.isObject(refs)) {
      refs = Object.keys(refs).map(it => {
        refs[it].name = it;
        return refs[it];
      });
    }
    schema.declare(refs);
  }
  let ret;
  if (props) {
    if (savUtil_cjs.isObject(props)) {
      props = Object.keys(props).map(it => {
        let val = props[it];
        if (!savUtil_cjs.isObject(val)) {
          val = { type: val };
        }
        if (savUtil_cjs.isFunction(val.type)) {
          val.type = val.type.name;
        }
        val.name = it;
        return val;
      });
    }
    let fields = props.map(it => {
      if (savUtil_cjs.isString(it) || savUtil_cjs.isNumber(it)) {
        return schema.idMap[it];
      }
      if (savUtil_cjs.isFunction(it.type)) {
        it.type = it.type.name;
      }
      let field = new SchemaField(schema, it);
      field.schemaType = SCHEMA_FIELD;
      return field;
    });
    ret = new SchemaStruct(schema, data);
    ret.schemaType = SCHEMA_STURCT;
    ret.fields = fields;
  } else if (refer) {
    ret = new SchemaRefer(schema, data);
    ret.schemaType = SCHEMA_REFER;
  } else if (list) {
    if (savUtil_cjs.isFunction(data.list)) {
      data.list = data.list.name;
    }
    ret = new SchemaList(schema, data);
    ret.schemaType = SCHEMA_LIST;
  } else if (enums) {
    ret = new SchemaEnum(schema, data);
    ret.schemaType = SCHEMA_ENUM;
  } else if (type) {
    ret = new SchemaField(schema, data);
    ret.schemaType = SCHEMA_FIELD;
    if ('id' in ret) {
      schema.idMap[ret.id] = ret;
    }
    return ret;
  }
  exportSchema(schema, ret);
  return ret;
}

function exportSchema(schema, ref) {
  if (ref.id) {
    schema.idMap[ref.id] = ref;
  }
  if (ref.name) {
    schema[ref.name] = schema.nameMap[ref.name] = ref;
  }
}

var index = new Schema();

exports.Schema = Schema;
exports.setErrors = setErrors;
exports['default'] = index;
exports.SCHEMA_TYPE = SCHEMA_TYPE;
exports.SCHEMA_ENUM = SCHEMA_ENUM;
exports.SCHEMA_STURCT = SCHEMA_STURCT;
exports.SCHEMA_LIST = SCHEMA_LIST;
exports.SCHEMA_REFER = SCHEMA_REFER;
exports.SCHEMA_FIELD = SCHEMA_FIELD;
});

unwrapExports(savSchema_cjs);
var savSchema_cjs_1 = savSchema_cjs.Schema;
var savSchema_cjs_4 = savSchema_cjs.SCHEMA_ENUM;

class Schema$$1 {
  constructor (opts) {
    this.opts = {
      schemaReqField: 'request',
      schemaResField: 'response',
      schemaReqPrefix: 'Req',
      schemaResPrefix: 'Res'
    };
    opts && this.setOptions(opts);
    this.schema = new savSchema_cjs_1();
  }
  setRouter (router) {
    router.on('declareAction', declareActionSchema.bind(this));
  }
  setOptions (opts) {
    Object.assign(this.opts, opts);
  }
  declare (schemas) {
    if (savUtil_cjs_5(schemas)) {
      for (let schemaName in schemas) {
        let schemaData = schemas[schemaName];
        schemaData.name = schemaName;
        this.schema.declare(schemaData);
      }
    } else if (savUtil_cjs_1(schemas)) {
      schemas.forEach(it => {
        this.schema.declare(it);
      });
    }
  }
  getSchema (schemaName) {
    return this.schema[schemaName]
  }
  get proxy () {
    let schema = new Proxy(this, {
      get (target, name) {
        return target.getSchema(name)
      }
    });
    return schema
  }
}

function declareActionSchema (actionRoute) {
  if (actionRoute.action) {
    extractSchema(actionRoute, this);
    extractSchema(actionRoute, this, true);
  }
}

function extractSchema (actionRoute, handler, isResponse) {
  let fieldName = isResponse ? handler.opts.schemaResField : handler.opts.schemaReqField;
  let structPrefix = isResponse ? handler.opts.schemaResPrefix : handler.opts.schemaReqPrefix;
  let value = actionRoute.action[fieldName];
  let structName = savUtil_cjs_51((structPrefix + '_' + actionRoute.name).replace(/\./g, '_'));
  if (savUtil_cjs_3(value)) {
    structName = value;
  } else if (savUtil_cjs_5(value)) {
    if (value.name) {
      structName = value.name;
    } else {
      value.name = structName;
    }
    let {schema} = handler;
    schema.declare(value);
  }
  actionRoute[isResponse ? 'response' : 'request'] = structName;
}

class SavBase {
  constructor (opts) {
    savUtil_cjs_29(this);
    this.opts = {
      name: 'sav',
      prod: true
    };
    this.shareOptions(this.router = new Router());
    this.shareOptions(this.modalAction = new ModalAction());
    this.shareOptions(this.schema = new Schema$$1());
    this.schema.setRouter(this.router);
    this.routes = {};
    this.router.on('declareAction', (route) => {
      if (route.actionName) {
        let name = route.name;
        this.routes[name] = route;
      }
    });
    this.mocks = {};
    this.init();
    this.setOptions(opts);
  }
  get name () {
    return this.opts.name
  }
  setOptions (opts) {
    Object.assign(this.opts, opts);
  }
  shareOptions (target) {
    target.opts = Object.assign(this.opts, target.opts);
  }
  declare ({actions, schemas, modals, mocks}) {
    if (schemas) {
      this.schema.declare(schemas);
    }
    if (modals) {
      this.router.declare(modals);
    }
    if (actions) {
      this.modalAction.declare(actions);
    }
    if (mocks) {
      Object.assign(this.mocks, mocks);
    }
  }
  resolvePayload (route, vueRoute) {
    let savRoute = this.routes[route.name];
    let schema = this.schema.getSchema(route.name);
    if (savRoute) {
      if (route.merge) {
        route.params = Object.assign({}, vueRoute.params, route.params);
        route.query = Object.assign({}, vueRoute.query, route.query);
      }
      route.path = savRoute.compile(route.params);
      savUtil_cjs_52(route, 'route', savRoute);
      savUtil_cjs_52(route, 'savHandle', this);
      return route
    } else if (schema) {
      let stateName = schema.opts.stateName || route.name;
      let stateData;
      if (schema.schemaType === savSchema_cjs_4) {
        stateData = JSON.parse(JSON.stringify(schema.opts.enums));
      } else {
        stateData = schema.create(Object.assign({}, schema.opts.state));
        if (route.merge) {
          Object.assign(stateData, vueRoute.params, vueRoute.query);
        }
      }
      route.state = {
        [`${stateName}`]: stateData
      };
      return route
    }
  }
  stripError (error) {
    let err;
    if (error instanceof Error) {
      err = Object.assign({
        message: error.message,
        type: error.constructor.name,
        stack: error.stack
      }, error);
    } else if (typeof err !== 'object') {
      return error
    }
    if (this.opts.prod) {
      delete err.step;
      delete err.stack;
      delete err.stacks;
    }
    if (!err.status) {
      if (!(error instanceof HttpError)) {
        err.status = 500;
      }
    }
    return err
  }
  mapPayloadState (argv) {
    let {route, output} = argv;
    let ret;
    if (savUtil_cjs_5(output)) {
      ret = mapping(argv, output) || mapping(route.action, output) || output;
      let {resState} = route.action;
      let name = resState || route.response;
      if ((resState !== false) && name) {
        return {[`${name}`]: ret}
      }
    }
    return ret
  }
}

function mapping (target, output) {
  let {mapState} = target;
  if (savUtil_cjs_1(mapState)) {
    return mapState.reduce((ret, name) => {
      ret[name] = getStatePath(output, name);
    }, {})
  } else if (savUtil_cjs_5(mapState)) {
    let ret = {};
    for (let name in mapState) {
      ret[name] = getStatePath(output, mapState[name]);
    }
    return ret
  } else if (savUtil_cjs_4(mapState)) {
    return mapState(output)
  }
  return output
}

function getStatePath (output, stateName) {
  let pos = stateName.indexOf('.');
  while (pos !== -1) {
    output = output[stateName.substring(0, pos)];
    if (!savUtil_cjs_5(output)) {
      return
    }
    stateName = stateName.substr(pos + 1);
    pos = stateName.indexOf('.');
  }
  return output[stateName]
}

function compose (middleware) {
  if (!Array.isArray(middleware)) throw new TypeError('Middleware stack must be an array!')
  for (const fn of middleware) {
    if (typeof fn !== 'function') throw new TypeError('Middleware must be composed of functions!')
  }

  /**
   * @param {Object} context
   * @return {Promise}
   * @api public
   */

  return function (context, next) {
    // last called middleware #
    let index = -1;
    return dispatch(0)
    function dispatch (i) {
      if (i <= index) return Promise.reject(new Error('next() called multiple times'))
      index = i;
      let fn = middleware[i];
      if (i === middleware.length) fn = next;
      if (!fn) return Promise.resolve()
      try {
        return Promise.resolve(fn(context, function next () {
          return dispatch(i + 1)
        }))
      } catch (err) {
        return Promise.reject(err)
      }
    }
  }
}

class Sav extends SavBase {
  constructor (opts) {
    super(Object.assign({
      ssr: false,
      prod: process.env.NODE_ENV === 'production'
    }, opts));
  }
  init () {
    this.vueRender = new VueRender(this);
    this.renders = {
      html: new HtmlRender(this)
    };
    this.invokeQueues = [this.invoke];
    this.composed = null;
  }
  before (fn) {
    this.invokeQueues.shift(fn);
  }
  after (fn) {
    this.invokeQueues.push(fn);
  }
  compose () {
    return composeInvokes(this)
  }
  exec (ctx) {
    let {composed} = this;
    if (!composed) {
      composed = this.composed = this.compose();
    }
    return composed(ctx)
  }
  prepare ({ctx, argv, sav}) {
    let {router, modalAction} = sav;
    let url = ctx.path || ctx.originalUrl;
    let accept = ctx.accepts(['html', 'json']);
    if (accept) {
      argv.accept = accept;
    }
    let mat = router.matchRoute(url, ctx.method.toUpperCase());
    if (!mat) {
      throw new HttpError(404)
    }
    Object.assign(argv, mat);
    let invoker = modalAction.getAction(mat.route.actionName);
    if (!invoker) {
      throw new HttpError(404)
    }
    savUtil_cjs_52(argv, 'invoker', invoker);
    argv.input = Object.assign({}, argv.params, ctx.query, mat.route.query, ctx.request.body);
  }
  async invoke ({ctx, argv, sav}, next$$1) {
    let {schema} = sav;
    let {route} = argv;
    let reqStruct = schema.getSchema(route.request);
    if (reqStruct) {
      try {
        reqStruct.check(argv.input, {replace: true});
      } catch (err) {
        err.status = 400;
        err.schema = reqStruct.name || reqStruct.id;
        throw err
      }
    }
    argv.output = await argv.invoker.call(sav, ctx, argv);
    let resStruct = schema.getSchema(route.response);
    if (resStruct) {
      try {
        resStruct.check(argv.output);
      } catch (err) {
        err.status = 500;
        err.schema = resStruct.name || resStruct.id;
        throw err
      }
    }
    return next$$1()
  }
  async invokePayload ({ctx, sav}, argv) {
    let {schema, modalAction} = sav;
    let {route} = argv;
    let invoker = modalAction.getAction(route.actionName);
    let isApi = route.api !== false;
    if (!invoker && isApi) {
      throw new HttpError(404)
    }
    let reqStruct = schema.getSchema(route.request);
    argv.input = Object.assign({}, argv.params, ctx.query, argv.query, argv.data);
    if (reqStruct) {
      try {
        reqStruct.check(argv.input, {replace: true});
      } catch (err) {
        err.status = 400;
        throw err
      }
    }
    if (isApi) {
      let output = argv.output = await invoker.call(sav, ctx, argv);
      let resStruct = schema.getSchema(route.response);
      if (resStruct) {
        resStruct.check(output);
      }
    }
    return this.mapPayloadState(argv)
  }
  render ({ctx, argv, sav}) {
    argv.state = argv.error ? {error: argv.error} : argv.output;
    let render = sav.renders[argv.accept];
    if (sav.opts.ssr && argv.accept === 'html') {
      if (argv.route && isClientView(argv.route)) {
        let mat = sav.vueRender.match(ctx);
        if (mat) {
          return sav.vueRender.render(ctx, mat)
        }
      }
    }
    if (render) {
      return render.render(ctx)
    } else {
      if (argv.error) {
        if (argv.error.status) {
          ctx.status = argv.error.status;
        }
      } else {
        ctx.status = 200;
      }
      ctx.body = argv.state;
    }
  }
}

function isClientView (route) {
  if (route.modal.view) {
    return route.action.view || (route.action.view !== false)
  }
  return !!route.action.view
}

function composeInvokes (sav) {
  let queues = compose(sav.invokeQueues);
  let schema = sav.schema.proxy;
  return (ctx, next$$1) => {
    Object.assign(ctx, {ctx, sav, schema, Exception, HttpError, argv: {}});
    return new Promise((resolve$$1, reject) => {
      sav.prepare(ctx);
      return queues(ctx, () => {
        return sav.render(ctx)
      }).then(resolve$$1).catch(reject)
    }).catch((err) => {
      ctx.argv.error = sav.stripError(err);
      return sav.render(ctx)
    })
  }
}

/**
 * 装饰器方法
 */

const ROUTES_KEY = '_routes_';

const get = routeMethod('GET');
const post = routeMethod('POST');
const head = routeMethod('HEAD');
const put = routeMethod('PUT');
const patch = routeMethod('PATCH');
const del = routeMethod('DELETE');

function routeMethod (method) {
  return (args) => {
    return (target, action, descriptor) => {
      let it = target[ROUTES_KEY] || (target[ROUTES_KEY] = {});
      it[action] = Object.assign({}, method && {method},
        typeof args === 'string' ? {path: args} : args);
      return descriptor.value
    }
  }
}

function Modal (props) {
  return (target) => {
    let routes = target.prototype[ROUTES_KEY];
    return Object.assign({}, props, routes && {routes})
  }
}

exports.Sav = Sav;
exports.STATUS_CODES = STATUS_CODES;
exports.Exception = Exception;
exports.HttpError = HttpError;
exports.get = get;
exports.post = post;
exports.head = head;
exports.put = put;
exports.patch = patch;
exports.del = del;
exports.Modal = Modal;
